[
["index.html", "Offensive Programming Book Welcome Book version Book production", " Offensive Programming Book Fabien GELINEAU neonira@gmail.com 2019-Q2 Welcome This is the website for “offensive programming”. This book will teach you how to put offensive programming in action with R. This website is and will remain free to use. It is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 3.0 License. Book version This book version is 1.2.1. It relates to following R package versions. R package version wyz.code.offensiveProgramming 1.1.12 wyz.code.testthat 1.1.9 wyz.code.metaTesting 1.1.3 wyz.code.rdoc 1.1.7 Book production The book is written in RMarkdown with bookdown. You may get access to the source for contributions. The book is for the moment just resulting of my efforts. Hope it will be enhanced and result from a collaborative effort very soon. This book is identified by ISBN 979-10-699-4075-8. "],
["preamble.html", "Preamble", " Preamble Package wyz.code.offensiveProgramming aims to provide a strict type checking enforcement in R. The R language is a weakly typed script language. As such, it simplifies greatly program writing and allows for great flexibility.That’s fine, and conceptually, there is no issue about that. Indeed, this leads more than desired to defensive programming practice. The absolute need to verify provided arguments, all along the function call chain, is very strong if you want to provide reliable and robust implementation. Consider following table about benefits of type control and type inference in lazy and strict type checking approaches. Goal Lazy type control (standard R) Strict type checking type control Weak type control implies coding of many contextual type controls Strong type checking brings some rigidity type inference requires knowledge and navigation from code to doc (forth and back) is required semantic naming allows more intuitive type inference Won’t it be nice to get the benefits of defensive programming and offensive programming, where ever and when ever needed? The main objective of package wyz.code.offensiveProgramming is to allow strict type checking in R to be as easy to use and to run as standard R "],
["programming-styles.html", " 1 Programming styles 1.1 Defensive programming style 1.2 Offensive programming style", " 1 Programming styles General reference might be found on wikiwand. 1.1 Defensive programming style Defensive programming style consist of implementation of many controls at the entry of functions. This is required to ensure parameters meet some conditions required by the developer or the context. There are some benefits to this style. It is clearly incremental, and you can always add as many controls as desired, to meet the level of robustness and reliability you aim for. Indeed, this comes with some drawbacks that are repeated verifications at various depth levels, and worst the executed verifications are often the same code, leading to a waste of time during implementation, testing and execution. Second, an evolution of any function signature in the function call chain, may imply shallow or deep changes in the subsequent verifications, depending of the case. Defensive programming style also requires a good documentation, as there is no way to infer rationally and with a high level of confidence, what type has to be used for a given parameter of a function. Notice, that quality and consistency of type and value verification changes from one package to another. 1.2 Offensive programming style Offensive programming styles works differently. It is based on an implicit contract with bilateral responsibilities developer implements required verification about values, not about types unless absolutely required, end-user provides values with right or wrong types, when using developer delivered package type checks can be enforced at any time by end-user if needed. They are not hard coded by the developer in each function. In this way, the contract, is end-user is responsible of type concordance and developer is responsible of implementation from type concordance. Instrumentation is provided to let the end-user easily check the type concordance. "],
["application-in-r-language.html", " 2 Application in R language 2.1 A simple case 2.2 Defensive programming 2.3 Offensive programming 2.4 Back to definition", " 2 Application in R language 2.1 A simple case Consider following R class implementation which provides some basic mathematics operations. MathOperation &lt;- function() { self &lt;- environment() class(self) &lt;- append(&#39;Addition&#39;, class(self)) add &lt;- function(x, y) x + y multiply &lt;- function(x, y) x * y divide &lt;- function(x, y) x / y self } Let’s not argue about the design and relevancy of the approach. Instead, can you tell the scopes of each function, and identify/inventorize the implementations flaws ? 2.2 Defensive programming In standard R, the provided implementation might behave correctly, erroneously, or even generate errors, depending on the inputs you provide. Is it bad code ? Not at all according to me. The class name mentions clearly the intent that is to encapsulate some math operations. There are 3 operations. They can take any argument that can be accepted by operators ‘+’, ’*’ or ‘/’. So, providing, integers, doubles, and complex numbers should work. If you use an external package like gmp, it is also an acceptable input for any of the needed parameters. Any combination of this types will provide a correct result, using scalars or vectors. From my point of view, main issues are the followings issue number issue description issue severity 1 few seconds for creation, several quarters of an hour for testing, and hours for documentation UNACCEPTABLE 2 does it complies with maths sets? Not at all, this is software engineering implementation, not a math compliant one SEVERE 3 high sensitivity to input values did you consider that NaN, NA, Inf, -Inf, 0 could be valid input values here?. Indeed R is naturally great on this part LOW 4 natural polymorphism of returned types, that brings again software engineering whereas reliable math ops are needed. From a mathematical point of view, input belong to a predefined mathematical set, and output belongs also to a predefined mathematical set. Not the case with provided implementations HIGH 5 unreliable implementation as input might return numeric output, warning or errors HIGH 2.3 Offensive programming Consider same R class implementation with a little bit instrumentation. suppressMessages(require(data.table)) MathOperation &lt;- function() { self &lt;- environment() class(self) &lt;- append(&#39;Addition&#39;, class(self)) add &lt;- function(x_r, y_r) x_r + y_r multiply &lt;- function(x_r, y_r) x_r * y_r divide &lt;- function(x_r, y_r) x_r / y_r function_return_types &lt;- data.table( function_name = c(&#39;add&#39;, &#39;multiply&#39;, &#39;divide&#39;), return_value = c(&#39;x_r&#39;, &#39;x_r&#39;, &#39;x_d&#39;) ) self } 2.3.1 What is different? Compare to previously shown implementation, here are the two main differences arguments are renamed according to a pattern a variable named function_return_types has been added. It holds a data.table that defines expected function return types. That’s it. Function implementation is exactly the same. No change done elsewhere. Everything is there and should be sufficient to solve many of the faced issues. 2.3.2 Semantic argument naming Arguments have been renamed from x to x_r. What does that mean? Syntactically, it changes nothing for R. For us humans, it changes a lot of things, as this follows a pattern that allows to specify several intents in a short, concise, and reliable way. The pattern is simple to understand. Its parts can be up to three, and the second and third parts are optional. First part, is the variable name. Second part is the type of the variable. Third part is the length constraint specification. Parts are separated by underscore. Refer to 5 for more details about syntax, and for illustrative examples. 2.4 Back to definition So now you may be able to translate the variable x_r by yourself. Just a vector of real values, unconstrained in length. Using this parameter name implies that the the developer is responsible for testing cases of various length and has to prevent weirdness propagation. For example following R code shows results that require decisions mo &lt;- MathOperation() print(mo$add(1.0 * 1:3, 1.0 * 1:7)) #&gt; Warning in x_r + y_r: la taille d&#39;un objet plus long n&#39;est pas multiple de #&gt; la taille d&#39;un objet plus court #&gt; [1] 2 4 6 5 7 9 8 This code provides both an output and a warning, because of R recycling on various length vectors. What decision should be taken ? Allow or deny this behavior ? It depends of your usage. If you are creating a real math library, I would recommend to duplicate the code and create two functions named addRCompliant and addMathCompliant. Later should enforce arguments length control in his body, while former should keep the body as is or instrument it with an encapsulating suppressWarning call. That way, you should easily meet your end-users expectations, either mathematicians or software engineers. Note that in the later case, added controls are not defensive programming but functional scope verification. "],
["putting-in-action-wyz-code-offensiveprogramming.html", " 3 Putting in action wyz.code.offensiveProgramming 3.1 Package overview", " 3 Putting in action wyz.code.offensiveProgramming The package provides R tools to ease offensive programming exploitation. 3.1 Package overview The package is organized around 4 axis that are elaboration, verification, exploitation and information. At any time you may get a list of the package functions by calling function packageFunctionsInformation that provides a truth table for each function in package wyz.code.offensiveProgramming. This is helpful when lost or just as a reminder. packageFunctionsInformation() #&gt; function elaboration verification #&gt; 1: defineEvaluationModes TRUE TRUE #&gt; 2: defineFunctionReturnTypesParameterName TRUE TRUE #&gt; 3: defineTestCaseDefinitionsParameterName TRUE TRUE #&gt; 4: EvaluationMode TRUE TRUE #&gt; 5: FunctionParameterTypeFactory TRUE TRUE #&gt; 6: FunctionParameterName TRUE TRUE #&gt; 7: TestCaseDefinition TRUE TRUE #&gt; 8: verifyClassName TRUE TRUE #&gt; 9: verifyFunctionName TRUE TRUE #&gt; 10: verifyObjectNames TRUE TRUE #&gt; 11: verifyFunctionReturnTypesDefinition TRUE TRUE #&gt; 12: verifyTestCaseDefinitions TRUE TRUE #&gt; 13: retrieveFunctionReturnTypes TRUE TRUE #&gt; 14: retrieveTestCaseDefinitions TRUE TRUE #&gt; 15: runFunction TRUE TRUE #&gt; 16: runTestCases TRUE TRUE #&gt; 17: isAuditable TRUE TRUE #&gt; 18: packageFunctionsInformation TRUE TRUE #&gt; exploitation information kind user #&gt; 1: TRUE TRUE information developer #&gt; 2: TRUE TRUE information developer #&gt; 3: TRUE TRUE information developer #&gt; 4: TRUE TRUE elaboration developer #&gt; 5: TRUE TRUE elaboration developer #&gt; 6: FALSE FALSE elaboration developer #&gt; 7: FALSE FALSE elaboration developer #&gt; 8: TRUE TRUE verification developer #&gt; 9: TRUE TRUE verification developer #&gt; 10: TRUE TRUE verification developer #&gt; 11: TRUE TRUE verification integrator #&gt; 12: TRUE TRUE verification integrator #&gt; 13: TRUE TRUE exploitation integrator #&gt; 14: TRUE TRUE exploitation integrator #&gt; 15: TRUE TRUE exploitation end-user #&gt; 16: TRUE TRUE exploitation end-user #&gt; 17: TRUE TRUE exploitation end-user #&gt; 18: TRUE TRUE information anyone "],
["the-type-factory.html", " 4 The type factory 4.1 Get recorded types inventory 4.2 Understanding the model 4.3 Register your own type 4.4 Get access to verification functions 4.5 Some hints 4.6 Enforcing use of your own type factory", " 4 The type factory The types that you wish to control are managed by a type factory, named FunctionParameterTypeFactory. Instantiating an object of this class allows you to discover what are the already recorded types, available for reuse register your own types so they can be checked dynamically wherever and whenever required understand the verification logic for each type 4.1 Get recorded types inventory Simply use retrieveFactory and getRecordedTypes function. It returns a data.table, that you can filter out conveniently. Here is an example. f &lt;- retrieveFactory() f$getRecordedTypes() #&gt; suffix type verify_function category #&gt; 1: a array &lt;function&gt; data structure #&gt; 2: b boolean &lt;function&gt; math #&gt; 3: c complex &lt;function&gt; numeric #&gt; 4: ca call &lt;function&gt; language #&gt; 5: ch character &lt;function&gt; basic #&gt; 6: cm complex-math &lt;function&gt; math #&gt; 7: d double &lt;function&gt; numeric #&gt; 8: da date &lt;function&gt; date #&gt; 9: dc POSIXct &lt;function&gt; date #&gt; 10: df data.frame &lt;function&gt; data structure #&gt; 11: dl POSIXlt &lt;function&gt; date #&gt; 12: dm double-math &lt;function&gt; math #&gt; 13: dt data.table &lt;function&gt; data structure #&gt; 14: e environment &lt;function&gt; basic #&gt; 15: er error &lt;function&gt; error management #&gt; 16: ex expression &lt;function&gt; language #&gt; 17: f function &lt;function&gt; basic #&gt; 18: fa factor &lt;function&gt; basic #&gt; 19: i integer &lt;function&gt; numeric #&gt; 20: im integer-math &lt;function&gt; math #&gt; 21: l list &lt;function&gt; data structure #&gt; 22: lo logical &lt;function&gt; basic #&gt; 23: m matrix &lt;function&gt; data structure #&gt; 24: n numeric &lt;function&gt; numeric #&gt; 25: na na &lt;function&gt; basic #&gt; 26: ni negative integer &lt;function&gt; math #&gt; 27: nm name &lt;function&gt; language #&gt; 28: nr negative real &lt;function&gt; math #&gt; 29: o object &lt;function&gt; basic #&gt; 30: pi positive integer &lt;function&gt; math #&gt; 31: pr positive real &lt;function&gt; math #&gt; 32: r real-math &lt;function&gt; math #&gt; 33: ra raw &lt;function&gt; basic #&gt; 34: rm real-math alias &lt;function&gt; math #&gt; 35: s string &lt;function&gt; basic #&gt; 36: t table &lt;function&gt; data structure #&gt; 37: ui unsigned integer &lt;function&gt; math #&gt; 38: ur unsigned real &lt;function&gt; math #&gt; 39: w warning &lt;function&gt; error management #&gt; suffix type verify_function category 4.2 Understanding the model A type is defined by three elements a unique suffix a unique name a function that returns a boolean value, TRUE when examining a value that matches the type For example, you might wonder what means ui as a suffix f$getRecordedTypes()[suffix == &#39;ui&#39;] #&gt; suffix type verify_function category #&gt; 1: ui unsigned integer &lt;function&gt; math What is the function related to suffix ui? f$getVerificationFunction(&#39;ui&#39;) #&gt; function(o_1_) isPureMathInteger(o_1_) &amp;&amp; o_1_ &gt;= 0L #&gt; &lt;bytecode: 0x000000001a681970&gt; #&gt; &lt;environment: 0x000000001a737758&gt; 4.3 Register your own type Type registration is achieved by providing a type suffix, a type name and a verification function. Registration will be tagged automatically as user-defined. Here is a typical sequence to register your own type f$addSuffix(&#39;mc&#39;, &#39;MyClass&#39;, function(o_1_) is(o_1_, &#39;MyClass&#39;)) #&gt; [1] TRUE f$getRecordedTypes()[suffix == &#39;mc&#39;] #&gt; suffix type verify_function category #&gt; 1: mc MyClass &lt;function&gt; user defined Note that no implementation of the class is required. It is purely declarative registration. You told the type factory to record the type MyClass under the suffix mc, with the verification function you provided. Here verification function is quite simple. Notice that it takes a single object as argument. 4.4 Get access to verification functions Implementation of verification function can range from quite simple to as complex as required. This allows you to manage functional scopes much more easily, whatever you work and organization context. For example, if you want to see at a glance the differences between a boolean and a logical, here is the sequence you could use f$getVerificationFunction(&#39;b&#39;) #&gt; function(o_1_) is.logical(o_1_) &amp;&amp; !is.na(o_1_) #&gt; &lt;bytecode: 0x000000001a674cc0&gt; #&gt; &lt;environment: 0x000000001a737758&gt; f$getVerificationFunction(&#39;logical&#39;) #&gt; function (x) .Primitive(&quot;is.logical&quot;) From the two definitions, you can deduce the differences between the two types. A boolean is a 2-value boolean, either TRUE or FALSE. A logical, is a R logical value, that is a 3-value boolean, so it may take value NA. Note that arguments to the function getVerificationFunction can be either a registered suffix or a registered type. 4.5 Some hints There is currently no way to remove one recorded type. This need is indeed very specific and arise only when there is a name collision and you wish to use an already taken name for your own purpose. Solution is quite simple, use another name. Provided types are the most commons, and the current suffixes have been chosen for ease of use and for intuitive usage. Whenever you need to register a new type, ask yourself ‘what is the suffix I wish to use for the new type?’. My advice is to use short suffixes, made of 2 or 3 letters. That’s clearly sufficient to distinguish your type from others. Know that there is not limitation to the length of the suffix you can use. Simply, comply with KISS, as you will have to type it several times, probably. If you come from another programming language, you may consider to create aliased types by recording new entries. Let’s look at a concrete case. f$addSuffix(&#39;ui&#39;, &#39;unsigned integer&#39;, function(o_1_) f$getVerificationFunction(&#39;i&#39;)(o_1_) &amp;&amp; o_1_ &gt;= 0L) #&gt; [1] FALSE f$addSuffix(&#39;ul&#39;, &#39;unsigned long&#39; , f$getVerificationFunction(&#39;ui&#39;)) #&gt; [1] TRUE f$getRecordedTypes()[suffix %in% c(&#39;ui&#39;, &#39;ul&#39;)] #&gt; suffix type verify_function category #&gt; 1: ui unsigned integer &lt;function&gt; math #&gt; 2: ul unsigned long &lt;function&gt; user defined You asked to add two new entries in the type factory, and they share the same verification function. First add fails, second one succeeds. The reason is that ui suffix is already defined and you cannot redefine an already defined suffix. Now, ui and ul are aliases of the same verification function. Notice that this is true now, and cannot be changed once created. Indeed, you always have the opportunity to create a new type factory to match your new need. You can use as many type factories as you want. The term alias shall not be understood, as an authorization to use one name for the other, but rather as an ability to define quickly new types to ease functional scope management. 4.6 Enforcing use of your own type factory When you customized your own type factory, you need a way to tell wyz.code.offensiveProgramming to use it. To do so, simply create your type factory and assign it to a R variable, and set environment variable OP_TYPE_FACTORY to point to the name of this R variable. Let’s see an example ff &lt;- FunctionParameterTypeFactory() ff$addSuffix(&#39;wo&#39;, &quot;wo class&quot;, function(o_) is(o_, &quot;wo&quot;)) #&gt; [1] TRUE ff$addSuffix(&#39;yo&#39;, &quot;yo class&quot;, function(o_) is(o_, &quot;yo&quot;)) #&gt; [1] TRUE ff$addSuffix(&#39;zo&#39;, &quot;zo class&quot;, function(o_) is(o_, &quot;zo&quot;)) #&gt; [1] TRUE Sys.setenv(&quot;OP_TYPE_FACTORY&quot; = &quot;ff&quot;) fg &lt;- retrieveFactory() # retrieves the factory pointed by R variable ff fg$getRecordedTypes()[suffix %in% c(&#39;wo&#39;, &#39;yo&#39;, &#39;zo&#39;)] # right behavior ! #&gt; suffix type verify_function category #&gt; 1: wo wo class &lt;function&gt; user defined #&gt; 2: yo yo class &lt;function&gt; user defined #&gt; 3: zo zo class &lt;function&gt; user defined # wrong behavior as retrieveFactory will provide the default factory and not yours! Sys.setenv(&quot;OP_TYPE_FACTORY&quot; = &quot;&quot;) fh &lt;- retrieveFactory() # retrieves the default factory fh$getRecordedTypes()[suffix %in% c(&#39;wo&#39;, &#39;yo&#39;, &#39;zo&#39;)] #&gt; Empty data.table (0 rows and 4 cols): suffix,type,verify_function,category "],
["semantic-names.html", " 5 Semantic names 5.1 What is semantic naming? 5.2 Verifying a function parameter or return type declaration 5.3 Verifying a class name 5.4 Verifying a function name 5.5 Get naming balance from an R object", " 5 Semantic names Package wyz.code.offensiveProgramming offers great functionalities at the cost of a few conditions semantic naming has to be used for function parameters names semantic naming has to be used for function return type definition semantic naming has to be used for test case definitions 5.1 What is semantic naming? I call semantic naming, the fact that a named object used in the code should provide much more information than a dumb name. Semantic naming in package wyz.code.offensiveProgramming defines a few patterns to declare class, function, function parameters and function return type names. Table below shows the related patterns and exposes the underlying philosophy. name category philosophy pattern to comply with class java like, starts with upper-cased letter, camel-cased [A-Z][a-ZA-Z0-9]* function java like, starts with lower-cased letter, camel-cased [a-z][a-ZA-Z0-9]* function parameter or function return type R like, bearing information about type and length constraint See below. Function parameter or return type names must comply with one of the following patterns &lt;variableNameCamelCase&gt;_&lt;typeInformation&gt;_&lt;lengthConstraint&gt; &lt;variableNameCamelCase&gt;_&lt;lengthConstraint&gt;_ First pattern is to be used for monomorphic types. Second one for polymorphic types. Monomorphic types are types that are homogeneous. A string, a double, a MyObject are good example of such monomorphic types. Pattern allows to not only express concisely the type, but also to express some length constraints if needed. Polymorphic types are useful as soon as your input or output can take many types, according to your context. For example, a R function may return a double, or a warning, or an error. Polymorphic types always end with ’_’ in their names, to make them easy to identify. The type information part of the pattern has to match one of the recorded entries of the type factory. The length constraint part ot the pattern follows the PERL pattern ([1-9][0-9]*(l|m|n)?). Letters mean respectively less or equal, more or equal, 1 or n. The length constraint part is optional. Look at following table to get more intuitive traction on function parameter or function return type declarations. input name meaning x_s an unconstrained vector of strings - might contain no entries x_s_3 a vector of strings with 3 entries x_s_3l a vector of strings with 3 or less entries x_s_3m a vector of strings with 3 or more entries x_s_3n a vector of strings with 3 entries or 1 entry flag_b_1 a vector of booleans with 1 entry - a.k.a a boolean scalar z_ an unconstrained polymorphic type vector named z - Nothing more is known about its content z_2_ a polymorphic type vector named z of length 2 - Nothing more is known about its content As you can see, rather easy. An advice, when programming try to use meaningful variable names for first part of the pattern. It will ease your job. 5.2 Verifying a function parameter or return type declaration Use simply dedicated function named getTypeDescription from the type factory. sapply(c(&#39;x_s_3n&#39;, &#39;flag_b_1&#39;, &#39;z_2_&#39;), function(e) f$getTypeDescription(FunctionParameterName(e))) #&gt; x_s_3n #&gt; &quot;A constrained vector of string values. Vector length must be 1 or 3.&quot; #&gt; flag_b_1 #&gt; &quot;A constrained vector of boolean objects. Vector length must be 1.&quot; #&gt; z_2_ #&gt; &quot;A constrained vector of variable type objects. Vector length must be 2.&quot; 5.3 Verifying a class name Simply use package eponymous function. verifyClassName(c(&#39;alphaBeta&#39;, &#39;AlphaBeta&#39;, &#39;.alphaBeta&#39;)) #&gt; alphaBeta AlphaBeta .alphaBeta #&gt; FALSE TRUE FALSE verifyClassName(c(&#39;alphaBeta&#39;, &#39;AlphaBeta&#39;, &#39;.alphaBeta&#39;), strict = FALSE) #&gt; alphaBeta AlphaBeta .alphaBeta #&gt; TRUE TRUE TRUE 5.4 Verifying a function name Simply use package eponymous function. verifyFunctionName(c(&#39;alphaBetaGamma&#39;, &#39;AlphaBetaGamma&#39;, &#39;.alphaBetaGamma&#39;)) #&gt; alphaBetaGamma AlphaBetaGamma .alphaBetaGamma #&gt; TRUE FALSE FALSE verifyFunctionName(c(&#39;alphaBetaGamma&#39;, &#39;AlphaBetaGamma&#39;, &#39;.alphaBetaGamma&#39;), strict = FALSE) #&gt; alphaBetaGamma AlphaBetaGamma .alphaBetaGamma #&gt; TRUE TRUE TRUE 5.5 Get naming balance from an R object Use package function verifyObjectNames to get the results of a full compliance analysis of names for the provided object. source(system.file(&#39;code-samples/no-defs/Addition.R&#39;, package = &#39;wyz.code.offensiveProgramming&#39;)) verifyObjectNames(Addition()) #&gt; $class_name_compliance #&gt; Addition #&gt; TRUE #&gt; #&gt; $function_name_compliance #&gt; addDouble addInteger addNumeric divideByZero #&gt; TRUE TRUE TRUE TRUE #&gt; generateError generateWarning #&gt; TRUE TRUE #&gt; #&gt; $parameter_name_compliance #&gt; function_name parameter_name name_compliance_check #&gt; 1: addDouble x_d TRUE #&gt; 2: addDouble y_d TRUE #&gt; 3: addInteger x_i TRUE #&gt; 4: addInteger y_i TRUE #&gt; 5: addNumeric x FALSE #&gt; 6: addNumeric y_n TRUE #&gt; 7: divideByZero x_n TRUE #&gt; 8: generateError &lt;NA&gt; TRUE #&gt; 9: generateWarning x_ TRUE #&gt; semantic_naming_check #&gt; 1: TRUE #&gt; 2: TRUE #&gt; 3: TRUE #&gt; 4: TRUE #&gt; 5: FALSE #&gt; 6: TRUE #&gt; 7: TRUE #&gt; 8: TRUE #&gt; 9: TRUE #&gt; #&gt; $classname #&gt; [1] &quot;Addition&quot; #&gt; #&gt; $owns_function_return_type_information #&gt; [1] FALSE #&gt; #&gt; $owns_test_case_definitions #&gt; [1] FALSE #&gt; #&gt; $supports_strict_compliance #&gt; [1] FALSE #&gt; #&gt; $supports_lazy_compliance #&gt; [1] FALSE #&gt; #&gt; $can_be_typed_checked #&gt; [1] FALSE #&gt; #&gt; $is_function_fully_instrumented #&gt; [1] FALSE #&gt; #&gt; $missing_functions #&gt; [1] NA #&gt; #&gt; $is_test_case_fully_instrumented #&gt; [1] FALSE #&gt; #&gt; $missing_test_cases #&gt; [1] NA #&gt; #&gt; $sof #&gt; $sof$frt #&gt; [1] FALSE #&gt; #&gt; $sof$tcd #&gt; [1] FALSE #&gt; #&gt; $sof$instrumented_fn #&gt; NULL #&gt; #&gt; $sof$instrumented_tc #&gt; NULL source(system.file(&#39;code-samples/both-defs/good/full/AdditionTCFIG1.R&#39;, package = &#39;wyz.code.offensiveProgramming&#39;)) verifyObjectNames(AdditionTCFIG1()) #&gt; $class_name_compliance #&gt; AdditionTCFIG1 #&gt; TRUE #&gt; #&gt; $function_name_compliance #&gt; addDouble addInteger addMultiDouble addMultiInteger #&gt; TRUE TRUE TRUE TRUE #&gt; divideByZero generateError generateWarning #&gt; TRUE TRUE TRUE #&gt; #&gt; $parameter_name_compliance #&gt; function_name parameter_name name_compliance_check #&gt; 1: addDouble x_d TRUE #&gt; 2: addDouble y_d TRUE #&gt; 3: addInteger x_i TRUE #&gt; 4: addInteger y_i TRUE #&gt; 5: addMultiDouble ... TRUE #&gt; 6: addMultiInteger x_i TRUE #&gt; 7: addMultiInteger ... TRUE #&gt; 8: divideByZero x_n TRUE #&gt; 9: generateError &lt;NA&gt; TRUE #&gt; 10: generateWarning x_ TRUE #&gt; semantic_naming_check #&gt; 1: TRUE #&gt; 2: TRUE #&gt; 3: TRUE #&gt; 4: TRUE #&gt; 5: TRUE #&gt; 6: TRUE #&gt; 7: TRUE #&gt; 8: TRUE #&gt; 9: TRUE #&gt; 10: TRUE #&gt; #&gt; $classname #&gt; [1] &quot;AdditionTCFIG1&quot; #&gt; #&gt; $owns_function_return_type_information #&gt; [1] TRUE #&gt; #&gt; $owns_test_case_definitions #&gt; [1] TRUE #&gt; #&gt; $supports_strict_compliance #&gt; [1] TRUE #&gt; #&gt; $supports_lazy_compliance #&gt; [1] TRUE #&gt; #&gt; $can_be_typed_checked #&gt; [1] TRUE #&gt; #&gt; $is_function_fully_instrumented #&gt; [1] TRUE #&gt; #&gt; $missing_functions #&gt; [1] &quot;none&quot; #&gt; #&gt; $is_test_case_fully_instrumented #&gt; [1] TRUE #&gt; #&gt; $missing_test_cases #&gt; [1] &quot;none&quot; #&gt; #&gt; $sof #&gt; $sof$frt #&gt; [1] TRUE #&gt; #&gt; $sof$tcd #&gt; [1] TRUE #&gt; #&gt; $sof$instrumented_fn #&gt; function_name return_value #&gt; 1: addDouble x_d #&gt; 2: addInteger x_i #&gt; 3: addMultiDouble x_d #&gt; 4: divideByZero x_d #&gt; 5: addMultiInteger x_i #&gt; 6: generateWarning x_w #&gt; 7: generateError x_er #&gt; #&gt; $sof$instrumented_tc #&gt; function_name standard_evaluation type_checking_enforcement #&gt; 1: addDouble correct correct #&gt; 2: addDouble correct correct #&gt; 3: addDouble correct correct #&gt; 4: addDouble correct correct #&gt; 5: addDouble correct correct #&gt; 6: addDouble erroneous erroneous #&gt; 7: addDouble correct failure #&gt; 8: addDouble correct failure #&gt; 9: addDouble correct failure #&gt; 10: addInteger correct correct #&gt; 11: addInteger correct correct #&gt; 12: addInteger correct correct #&gt; 13: addInteger correct correct #&gt; 14: addInteger erroneous failure #&gt; 15: addInteger correct failure #&gt; 16: addInteger correct failure #&gt; 17: addInteger correct failure #&gt; 18: addInteger correct failure #&gt; 19: divideByZero correct correct #&gt; 20: divideByZero correct correct #&gt; 21: divideByZero correct correct #&gt; 22: generateWarning correct correct #&gt; 23: generateError failure failure #&gt; 24: addMultiDouble correct correct #&gt; 25: addMultiDouble correct correct #&gt; 26: addMultiDouble correct correct #&gt; 27: addMultiInteger correct correct #&gt; 28: addMultiInteger correct failure #&gt; 29: addMultiInteger correct correct #&gt; function_name standard_evaluation type_checking_enforcement #&gt; test_case #&gt; 1: &lt;TestCaseDefinition&gt; #&gt; 2: &lt;TestCaseDefinition&gt; #&gt; 3: &lt;TestCaseDefinition&gt; #&gt; 4: &lt;TestCaseDefinition&gt; #&gt; 5: &lt;TestCaseDefinition&gt; #&gt; 6: &lt;TestCaseDefinition&gt; #&gt; 7: &lt;TestCaseDefinition&gt; #&gt; 8: &lt;TestCaseDefinition&gt; #&gt; 9: &lt;TestCaseDefinition&gt; #&gt; 10: &lt;TestCaseDefinition&gt; #&gt; 11: &lt;TestCaseDefinition&gt; #&gt; 12: &lt;TestCaseDefinition&gt; #&gt; 13: &lt;TestCaseDefinition&gt; #&gt; 14: &lt;TestCaseDefinition&gt; #&gt; 15: &lt;TestCaseDefinition&gt; #&gt; 16: &lt;TestCaseDefinition&gt; #&gt; 17: &lt;TestCaseDefinition&gt; #&gt; 18: &lt;TestCaseDefinition&gt; #&gt; 19: &lt;TestCaseDefinition&gt; #&gt; 20: &lt;TestCaseDefinition&gt; #&gt; 21: &lt;TestCaseDefinition&gt; #&gt; 22: &lt;TestCaseDefinition&gt; #&gt; 23: &lt;TestCaseDefinition&gt; #&gt; 24: &lt;TestCaseDefinition&gt; #&gt; 25: &lt;TestCaseDefinition&gt; #&gt; 26: &lt;TestCaseDefinition&gt; #&gt; 27: &lt;TestCaseDefinition&gt; #&gt; 28: &lt;TestCaseDefinition&gt; #&gt; 29: &lt;TestCaseDefinition&gt; #&gt; test_case "],
["evaluation-modes.html", " 6 Evaluation modes 6.1 Understanding evaluation modes 6.2 Instantiating evaluation mode", " 6 Evaluation modes Package wyz.code.offensiveProgramming comes with several evaluation modes. You may retrieve them by using function defineEvaluationModes that returns the 3 following modes standard_R_evaluation enhanced_R_evaluation type_checking_enforcement 6.1 Understanding evaluation modes The first mode, standard_R_evaluation, is to ease comparisons with standard R evaluation. It does not make any sense to use only this mode when using wyz.code.offensiveProgramming. The second mode, enhanced_R_evaluation, goes further than standard R evaluation, as it implies a function return type verification. The third mode, type_checking_enforcement, goes still further than the second mode, as it implies a function parameter types verification. Roughly speaking, second mode let’s you verify function return types in accordance with recorded information, and the third mode, mimics a compiler output for R but it still interpreted language. 6.2 Instantiating evaluation mode To handle evaluation mode, use function EvaluationMode. A typical way to do so is print(defineEvaluationModes()) #&gt; [1] &quot;standard_R_evaluation&quot; &quot;enhanced_R_evaluation&quot; #&gt; [3] &quot;type_checking_enforcement&quot; em &lt;- EvaluationMode(defineEvaluationModes()[3]) # convenient definitions, I will reuse in the coming book chapters to simplify writing emo &lt;- list( standard = EvaluationMode(defineEvaluationModes()[1]), enhanced = EvaluationMode(defineEvaluationModes()[2]), type = EvaluationMode(defineEvaluationModes()[3]) ) "],
["running-functions.html", " 7 Running functions 7.1 Prerequisites 7.2 Function return types definition verification 7.3 Transient invocations 7.4 Persistent invocations", " 7 Running functions Our goal is to run a R instrumented function, under a given evaluation mode. To do so, some prerequisites have to be met, prior to use some wyz.code.offensiveProgramming utilities to proceed to the function execution with context capture and human-readable feedback generation. 7.1 Prerequisites To run a R function is has to be instrumented. Two requirements have to be met the function must comply with semantic parameter naming the function return type must be specified 7.2 Function return types definition verification To verify function return types definition you may use the low level function verifyFunctionReturnTypesDefinition or the higher level one named retrieveFunctionReturnTypes. Indeed, this approach requires persistent instrumentation of the code. retrieveFunctionReturnTypes(AdditionTCFIG1()) #&gt; function_name return_value #&gt; 1: addDouble x_d #&gt; 2: addInteger x_i #&gt; 3: addMultiDouble x_d #&gt; 4: divideByZero x_d #&gt; 5: addMultiInteger x_i #&gt; 6: generateWarning x_w #&gt; 7: generateError x_er 7.3 Transient invocations Transient means instrumentation is done dynamically and not persisted anywhere. Here is a typical case. That’s a convenient way to discover and to play with package wyz.code.offensiveProgramming. 7.3.1 Nominal case To get the definition for ‘emo’ variable, please refer to 6. h &lt;- function(x_s) x_s runTransientFunction(h, list(&#39;neonira&#39;), emo$type, &#39;x_s&#39;) #&gt; $status #&gt; [1] TRUE #&gt; #&gt; $value #&gt; [1] &quot;neonira&quot; #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_s neonira TRUE good type in values #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_s neonira TRUE good type in values Semantically, function h takes a vector of strings as argument and returns a vector of strings. As provided parameter ‘neonira’ is a vector of type character, parameter_type_checks succeed. As returned value is a vector of type character, function_return_type_check also succeeds. 7.3.1.1 Wrong parameter type Let’s change the provided argument from ‘neonira’ to pi value. h &lt;- function(x_s) x_s runTransientFunction(h, list(pi), emo$type, &#39;x_s&#39;) #&gt; $status #&gt; [1] FALSE #&gt; #&gt; $value #&gt; [1] 3.141593 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_s 3.141593 FALSE wrong type in values #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_s 3.141593 FALSE wrong type in values We now face a case where function specification is unchanged but provided argument is not complying to specification. Impact is parameter_type_checks failure and function_return_type_check failure. 7.3.1.2 Change expected return type Let’s change the expected function return type, to be double x_d. h &lt;- function(x_s) x_s runTransientFunction(h, list(pi), emo$type, &#39;x_d&#39;) #&gt; $status #&gt; [1] FALSE #&gt; #&gt; $value #&gt; [1] 3.141593 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_s 3.141593 FALSE wrong type in values #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_d 3.141593 TRUE good type in values We now face a case where function specification is unchanged but expected return type is expected to be a double. Provided argument is not complying to specification. Impact is parameter_type_checks failure. 7.3.2 Prerequisite mismatch What if function is not fulfilling prerequisites g &lt;- function(x) x # No semantic name compliance runTransientFunction(g, list(pi), EvaluationMode(defineEvaluationModes()[3]), &#39;x_d&#39;) #&gt; $status #&gt; [1] FALSE #&gt; #&gt; $value #&gt; [1] 3.141593 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x 3.141593 FALSE unknown suffix, [NA] #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_d 3.141593 TRUE good type in values Impact is parameter_type_checks failure. 7.3.3 Object function call What if the function you desire to call is an object function? In such a case, be sure to pass the object as first parameter of the list of parameters, as shown by example below, based on a S3 object. A priori, all kind of R objects are supported: S3, S4, RC, R6 and environment objects. library(data.table) source(file.path(system.file(package = &#39;wyz.code.offensiveProgramming&#39;), &#39;code-samples&#39;, &#39;both-defs/good/partial&#39;, &#39;Addition_TCFI_Partial_S3.R&#39;), encoding = &#39;UTF-8&#39;) a &lt;- Addition_TCFI_Partial_S3() runTransientFunction(addInteger.Addition_TCFI_Partial_S3, list(a, 3L, 4L), emo$type, &#39;x_i&#39;) #&gt; $status #&gt; [1] FALSE #&gt; #&gt; $value #&gt; [1] 7 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity #&gt; 1: object_o_1 &lt;Addition_TCFI_Partial_S3&gt; FALSE #&gt; 2: x_i 3 TRUE #&gt; 3: y_i 4 TRUE #&gt; message #&gt; 1: wrong length, was expecting [1] , got [3] #&gt; 2: good type in values #&gt; 3: good type in values #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 7 TRUE good type in values runTransientFunction(addInteger.Addition_TCFI_Partial_S3, list(NULL, 3L, 4L), emo$type, &#39;x_i&#39;) #&gt; $status #&gt; [1] FALSE #&gt; #&gt; $value #&gt; [1] 7 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity #&gt; 1: object_o_1 FALSE #&gt; 2: x_i 3 TRUE #&gt; 3: y_i 4 TRUE #&gt; message #&gt; 1: wrong length, was expecting [1] , got [0] #&gt; 2: good type in values #&gt; 3: good type in values #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 7 TRUE good type in values print(ls()) #&gt; [1] &quot;a&quot; #&gt; [2] &quot;addDouble.Addition_TCFI_Partial_S3&quot; #&gt; [3] &quot;addInteger&quot; #&gt; [4] &quot;addInteger.Addition_TCFI_Partial_S3&quot; #&gt; [5] &quot;Addition&quot; #&gt; [6] &quot;Addition_TCFI_Partial_S3&quot; #&gt; [7] &quot;AdditionTCFIG1&quot; #&gt; [8] &quot;addNumeric&quot; #&gt; [9] &quot;addNumeric.Addition_TCFI_Partial_S3&quot; #&gt; [10] &quot;divideByZero.Addition_TCFI_Partial_S3&quot; #&gt; [11] &quot;em&quot; #&gt; [12] &quot;emo&quot; #&gt; [13] &quot;f&quot; #&gt; [14] &quot;ff&quot; #&gt; [15] &quot;fg&quot; #&gt; [16] &quot;fh&quot; #&gt; [17] &quot;g&quot; #&gt; [18] &quot;generateError&quot; #&gt; [19] &quot;generateError.Addition_TCFI_Partial_S3&quot; #&gt; [20] &quot;generateWarning.Addition_TCFI_Partial_S3&quot; #&gt; [21] &quot;generateWarning2&quot; #&gt; [22] &quot;generateWarning2.Addition_TCFI_Partial_S3&quot; #&gt; [23] &quot;h&quot; #&gt; [24] &quot;MathOperation&quot; #&gt; [25] &quot;mo&quot; #runTransientFunction(addInteger, list(a, 3L, 4L), emo$type, &#39;x_i&#39;) 7.4 Persistent invocations Transient invocations are convenient but limited. Especially, when you create classes, they do not appear to be as friendly and useful as necessary. When dealing with your own class code, you may opt for an easier and more industrial approach that is class instrumentation. Prerequisite remains the same, but you may fulfill them much more easily by defining a variable named function_return_type in your class. Let’s see an example. 7.4.1 Nominal persistent case source(system.file(&#39;code-samples/frt-defs/good/partial/AdditionFIPartial.R&#39;, package = &#39;wyz.code.offensiveProgramming&#39;)) runFunction(AdditionFIPartial(), &#39;addInteger&#39;, list(1:3, 6:8), emo$type) #&gt; $status #&gt; [1] TRUE #&gt; #&gt; $value #&gt; [1] 7 9 11 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $function_return_check #&gt; [1] TRUE #&gt; #&gt; $parameter_check #&gt; [1] TRUE #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 1,2,3 TRUE good type in values #&gt; 2: y_i 6,7,8 TRUE good type in values #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 7, 9,11 TRUE good type in values We now face a case where function specification is expecting to sum integers. Provided arguments are complying to specification. Impact is parameter_type_checks success and function_return_type_check success. 7.4.2 Subtile change Just change the function name. Now expectations brought by the function definition are not the same. This leads to a completely different result. runFunction(AdditionFIPartial(), &#39;addDouble&#39;, list(1:3, 6:8), emo$type) #&gt; $status #&gt; [1] FALSE #&gt; #&gt; $value #&gt; [1] 7 9 11 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $function_return_check #&gt; [1] FALSE #&gt; #&gt; $parameter_check #&gt; [1] FALSE #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_d 1,2,3 FALSE wrong type in values #&gt; 2: y_d 6,7,8 FALSE wrong type in values #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_d 7, 9,11 FALSE wrong type in values 7.4.3 Call case with named and positional parameters runFunction(AdditionFIPartial(), &#39;addInteger&#39;, list(y_i = 1:3, 6:8), emo$type) #&gt; $status #&gt; [1] TRUE #&gt; #&gt; $value #&gt; [1] 7 9 11 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $function_return_check #&gt; [1] TRUE #&gt; #&gt; $parameter_check #&gt; [1] TRUE #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: y_i 1,2,3 TRUE good type in values #&gt; 2: x_i 6,7,8 TRUE good type in values #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 7, 9,11 TRUE good type in values Look at parameter_type_checks to ensure arguments are well associated. 7.4.4 Call case with ellipsis runFunction(AdditionFIPartial(), &#39;addMultiDouble&#39;, list(1:3, 1:7), emo$type) #&gt; $status #&gt; [1] TRUE #&gt; #&gt; $value #&gt; [1] 34 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $function_return_check #&gt; [1] TRUE #&gt; #&gt; $parameter_check #&gt; [1] TRUE #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: ... 1,2,3 TRUE ellipsis matches all #&gt; 2: ... 1,2,3,4,5,6,... TRUE ellipsis matches all #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_d 34 TRUE good type in values 7.4.5 Second call case with ellipsis runFunction(AdditionFIPartial(), &#39;addMultiInteger&#39;, list(1:3, 1:7, 0, floor(pi)), emo$type) #&gt; $status #&gt; [1] FALSE #&gt; #&gt; $value #&gt; [1] 32 33 34 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $function_return_check #&gt; [1] FALSE #&gt; #&gt; $parameter_check #&gt; [1] TRUE #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 1,2,3 TRUE good type in values #&gt; 2: ... 1,2,3,4,5,6,... TRUE ellipsis matches all #&gt; 3: ... 0 TRUE ellipsis matches all #&gt; 4: ... 3 TRUE ellipsis matches all #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 32,33,34 FALSE wrong type in values Two issues here. Value 0 is double, not integer and floor function returns also a double. To get a correct results here is how to transform the call runFunction(AdditionFIPartial(), &#39;addMultiInteger&#39;, list(1:3, 1:7, 0L, as.integer(floor(pi))), emo$type) #&gt; $status #&gt; [1] TRUE #&gt; #&gt; $value #&gt; [1] 32 33 34 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $function_return_check #&gt; [1] TRUE #&gt; #&gt; $parameter_check #&gt; [1] TRUE #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 1,2,3 TRUE good type in values #&gt; 2: ... 1,2,3,4,5,6,... TRUE ellipsis matches all #&gt; 3: ... 0 TRUE ellipsis matches all #&gt; 4: ... 3 TRUE ellipsis matches all #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 32,33,34 TRUE good type in values "],
["running-test-cases.html", " 8 Running test cases 8.1 Reusing defined test case definitions 8.2 Embedding test cases in class definition 8.3 Test case definitions verification 8.4 Discovering test cases descriptions 8.5 Run a test case", " 8 Running test cases Using package wyz.code.offensiveProgramming, you have the opportunity to define test cases and to embed them in your class definition, to ease retrieval and reuse. 8.1 Reusing defined test case definitions Doing so, allows to get following benefits discover defined test case definitions run of any test case definition get interactively the R code of a test case, allowing you to play with it, manually, when needed get contextual results from the test case runs 8.2 Embedding test cases in class definition This is accomplished easily. You just have to declare a variable named testCaseDefinitions, and provide its content, that is a data.table. Content could be partial or complete depending of your goals. Spectrum of provided tests cases is as you desire it to be, as shallow or deep as needed. The data.table must hold following columns and content function_name, a vector of strings, each being the name of the function to test, standard_evaluation, a vector of strings, where values are taken from set {‘correct’, ‘erroneous’, ‘failure’} type_checking_enforcement, , a vector of strings, where values are taken from set {‘correct’, ‘erroneous’, ‘failure’} test case definitions, that is a list of TestCaseDefinition objects. Correct implies right type and right result. Erroneous implies right type and wrong result. Failure implies wrong type. To get more details about syntax, please refer to manual page of Definitions. 8.2.1 A simple case source(system.file(&#39;code-samples/both-defs/good/partial/AdditionTCFIP.R&#39;, package = &#39;wyz.code.offensiveProgramming&#39;)) AdditionTCFIP #&gt; function () #&gt; { #&gt; self &lt;- environment() #&gt; class(self) &lt;- append(&quot;AdditionTCFIP&quot;, class(self)) #&gt; addNumeric &lt;- function(x_n, y_n) x_n + y_n #&gt; addDouble &lt;- function(x_d, y_d = 0, ...) x_d + y_d + ... #&gt; addInteger &lt;- function(x_i, y_i) x_i + y_i #&gt; divideByZero &lt;- function(x_n) x_n/0 #&gt; generateWarning &lt;- function(x_ = 8L) 1:3 + 1:7 + x_ #&gt; generateError &lt;- function() stop(&quot;generated error&quot;) #&gt; function_return_types &lt;- data.table(function_name = c(&quot;addNumeric&quot;, #&gt; &quot;addDouble&quot;, &quot;addInteger&quot;, &quot;divideByZero&quot;, &quot;generateWarning&quot;, #&gt; &quot;generateError&quot;), return_value = c(&quot;x_n&quot;, &quot;x_d&quot;, &quot;x_i&quot;, #&gt; &quot;x_d&quot;, &quot;x_w&quot;, &quot;x_er&quot;)) #&gt; test_case_definitions &lt;- data.table(function_name = c(&quot;addInteger&quot;, #&gt; &quot;divideByZero&quot;, &quot;divideByZero&quot;, &quot;generateWarning&quot;, &quot;generateError&quot;), #&gt; standard_evaluation = c(&quot;correct&quot;, &quot;correct&quot;, &quot;correct&quot;, #&gt; &quot;correct&quot;, &quot;failure&quot;), type_checking_enforcement = c(&quot;erroneous&quot;, #&gt; &quot;correct&quot;, &quot;correct&quot;, &quot;correct&quot;, &quot;correct&quot;), test_case = list(TestCaseDefinition(list(34L, #&gt; 44.5), 78L, &quot;sum 1 integer and 1 double&quot;), TestCaseDefinition(list(1), #&gt; Inf, &quot;1 / 0&quot;), TestCaseDefinition(list(0), NaN, &quot;0 / 0&quot;), #&gt; TestCaseDefinition(list(0), 1:3 + 1:7, &quot;generate warning&quot;), #&gt; TestCaseDefinition(list(), NA, &quot;generate error&quot;))) #&gt; self #&gt; } Just five test cases to test 5 function with various parameters. 8.2.2 A more complex case AdditionTCFIG1 #&gt; function () #&gt; { #&gt; self &lt;- environment() #&gt; class(self) &lt;- append(&quot;AdditionTCFIG1&quot;, class(self)) #&gt; addDouble &lt;- function(x_d, y_d) x_d + y_d #&gt; addInteger &lt;- function(x_i, y_i) x_i + y_i #&gt; addMultiDouble &lt;- function(...) as.double(sum(..., na.rm = TRUE)) #&gt; addMultiInteger &lt;- function(x_i, ...) x_i + sum(..., na.rm = TRUE) #&gt; divideByZero &lt;- function(x_n) x_n/0 #&gt; generateWarning &lt;- function(x_) 1:3 + 1:7 #&gt; generateError &lt;- function() stop(&quot;generated error&quot;) #&gt; function_return_types &lt;- data.table(function_name = c(&quot;addDouble&quot;, #&gt; &quot;addInteger&quot;, &quot;addMultiDouble&quot;, &quot;divideByZero&quot;, &quot;addMultiInteger&quot;, #&gt; &quot;generateWarning&quot;, &quot;generateError&quot;), return_value = c(&quot;x_d&quot;, #&gt; &quot;x_i&quot;, &quot;x_d&quot;, &quot;x_d&quot;, &quot;x_i&quot;, &quot;x_w&quot;, &quot;x_er&quot;)) #&gt; test_case_definitions &lt;- data.table(function_name = c(rep(&quot;addDouble&quot;, #&gt; 9), rep(&quot;addInteger&quot;, 9), rep(&quot;divideByZero&quot;, 3), &quot;generateWarning&quot;, #&gt; &quot;generateError&quot;, rep(&quot;addMultiDouble&quot;, 3), rep(&quot;addMultiInteger&quot;, #&gt; 3)), standard_evaluation = c(rep(&quot;correct&quot;, 5), &quot;erroneous&quot;, #&gt; rep(&quot;correct&quot;, 7), &quot;erroneous&quot;, rep(&quot;correct&quot;, 8), &quot;failure&quot;, #&gt; rep(&quot;correct&quot;, 6)), type_checking_enforcement = c(rep(&quot;correct&quot;, #&gt; 5), &quot;erroneous&quot;, rep(&quot;failure&quot;, 3), rep(&quot;correct&quot;, 4), #&gt; rep(&quot;failure&quot;, 5), rep(&quot;correct&quot;, 3), &quot;correct&quot;, &quot;failure&quot;, #&gt; &quot;correct&quot;, &quot;correct&quot;, &quot;correct&quot;, &quot;correct&quot;, &quot;failure&quot;, #&gt; &quot;correct&quot;), test_case = list(TestCaseDefinition(list(as.double(34L), #&gt; 44.5), 78.5, &quot;sum 2 doubles&quot;), TestCaseDefinition(list(34, #&gt; NA_real_), NA_real_, &quot;sum 1 double and 1 NA_real_&quot;), #&gt; TestCaseDefinition(list(NA_real_, NA_real_), NA_real_, #&gt; &quot;sum 2 NA_real_&quot;), TestCaseDefinition(list(NaN, NaN), #&gt; NaN, &quot;sum 2 NAN&quot;), TestCaseDefinition(list(Inf, Inf), #&gt; Inf, &quot;sum 2 Inf&quot;), TestCaseDefinition(list(as.integer(34.7), #&gt; as.integer(44.9)), 80, &quot;sum 2 as.integers confused with sum of rounded value as expectation&quot;), #&gt; TestCaseDefinition(list(34L, 44.5), 78.5, &quot;sum of 1 integer and 1 double&quot;), #&gt; TestCaseDefinition(list(34, NA_integer_), NA_real_, &quot;sum of 1 integer and 1 double&quot;), #&gt; TestCaseDefinition(list(NA, NA), NA, &quot;sum 2 NA&quot;), TestCaseDefinition(list(34L, #&gt; as.integer(44.5)), 78L, &quot;sum 2 integers&quot;), TestCaseDefinition(list(34L, #&gt; NA_integer_), NA_integer_, &quot;sum 1 integer and 1 NA_integer&quot;), #&gt; TestCaseDefinition(list(NA_integer_, NA_integer_), NA_integer_, #&gt; &quot;sum 2 NA_integer&quot;), TestCaseDefinition(list(as.integer(&quot;45.654&quot;), #&gt; 44L), 89L, &quot;sum a converted string with one integer&quot;), #&gt; TestCaseDefinition(list(34L, 44.5), 78L, &quot;sum 1 integer and 1 double&quot;), #&gt; TestCaseDefinition(list(34L, Inf), Inf, &quot;sum 1 integer and 1 Inf&quot;), #&gt; TestCaseDefinition(list(34L, NaN), NaN, &quot;sum 1 integer and 1 NAN&quot;), #&gt; TestCaseDefinition(list(34L, NA), NA, &quot;sum 1 integer and 1 NA&quot;), #&gt; TestCaseDefinition(list(c(34L, 35L), 44L), c(78L, 79L), #&gt; &quot;sum a vector of 2 integers with 1 integer&quot;), TestCaseDefinition(list(1), #&gt; Inf, &quot;1 / 0&quot;), TestCaseDefinition(list(-1), -Inf, #&gt; &quot;-1 / 0&quot;), TestCaseDefinition(list(0), NaN, &quot;0 / 0&quot;), #&gt; TestCaseDefinition(list(0), 1:3 + 1:7, &quot;generate warning&quot;), #&gt; TestCaseDefinition(list(), NA, &quot;generate error&quot;), TestCaseDefinition(list(34L, #&gt; 44.5), 78.5, &quot;sum of 1 integer and 1 double&quot;), TestCaseDefinition(list(34, #&gt; 35L, 36L, NA_integer_), 105, &quot;sum of 1 double, 2 integers and 1 NA_integer_&quot;), #&gt; TestCaseDefinition(list(), 0, &quot;sum of nothing&quot;), TestCaseDefinition(list(34L, #&gt; 44L, 1L, 1L), 80L, &quot;sum of 4 integers&quot;), TestCaseDefinition(list(34L, #&gt; 35, 36, NA_integer_), 105, &quot;sum of 1 integer, 2 doubles and 1 NA_integer_&quot;), #&gt; TestCaseDefinition(list(34L), 34L, &quot;sum of one integer and nothing&quot;))) #&gt; label &lt;- &quot;erroneous class instrumentation: test cases uses function divideByZero that is not instrumented for type checking enforcement&quot; #&gt; self #&gt; } #&gt; &lt;bytecode: 0x000000001b062cd0&gt; Much more complete instrumentation with 29 test cases, various expected outputs, varying from evaluation model to consider. 8.3 Test case definitions verification To verify test cases definitions you may use the low level function verifyTestCaseDefinitions or the higher level one named retrieveTestCaseDefinitions. retrieveTestCaseDefinitions(AdditionTCFIG1()) #&gt; function_name standard_evaluation type_checking_enforcement #&gt; 1: addDouble correct correct #&gt; 2: addDouble correct correct #&gt; 3: addDouble correct correct #&gt; 4: addDouble correct correct #&gt; 5: addDouble correct correct #&gt; 6: addDouble erroneous erroneous #&gt; 7: addDouble correct failure #&gt; 8: addDouble correct failure #&gt; 9: addDouble correct failure #&gt; 10: addInteger correct correct #&gt; 11: addInteger correct correct #&gt; 12: addInteger correct correct #&gt; 13: addInteger correct correct #&gt; 14: addInteger erroneous failure #&gt; 15: addInteger correct failure #&gt; 16: addInteger correct failure #&gt; 17: addInteger correct failure #&gt; 18: addInteger correct failure #&gt; 19: divideByZero correct correct #&gt; 20: divideByZero correct correct #&gt; 21: divideByZero correct correct #&gt; 22: generateWarning correct correct #&gt; 23: generateError failure failure #&gt; 24: addMultiDouble correct correct #&gt; 25: addMultiDouble correct correct #&gt; 26: addMultiDouble correct correct #&gt; 27: addMultiInteger correct correct #&gt; 28: addMultiInteger correct failure #&gt; 29: addMultiInteger correct correct #&gt; function_name standard_evaluation type_checking_enforcement #&gt; test_case #&gt; 1: &lt;TestCaseDefinition&gt; #&gt; 2: &lt;TestCaseDefinition&gt; #&gt; 3: &lt;TestCaseDefinition&gt; #&gt; 4: &lt;TestCaseDefinition&gt; #&gt; 5: &lt;TestCaseDefinition&gt; #&gt; 6: &lt;TestCaseDefinition&gt; #&gt; 7: &lt;TestCaseDefinition&gt; #&gt; 8: &lt;TestCaseDefinition&gt; #&gt; 9: &lt;TestCaseDefinition&gt; #&gt; 10: &lt;TestCaseDefinition&gt; #&gt; 11: &lt;TestCaseDefinition&gt; #&gt; 12: &lt;TestCaseDefinition&gt; #&gt; 13: &lt;TestCaseDefinition&gt; #&gt; 14: &lt;TestCaseDefinition&gt; #&gt; 15: &lt;TestCaseDefinition&gt; #&gt; 16: &lt;TestCaseDefinition&gt; #&gt; 17: &lt;TestCaseDefinition&gt; #&gt; 18: &lt;TestCaseDefinition&gt; #&gt; 19: &lt;TestCaseDefinition&gt; #&gt; 20: &lt;TestCaseDefinition&gt; #&gt; 21: &lt;TestCaseDefinition&gt; #&gt; 22: &lt;TestCaseDefinition&gt; #&gt; 23: &lt;TestCaseDefinition&gt; #&gt; 24: &lt;TestCaseDefinition&gt; #&gt; 25: &lt;TestCaseDefinition&gt; #&gt; 26: &lt;TestCaseDefinition&gt; #&gt; 27: &lt;TestCaseDefinition&gt; #&gt; 28: &lt;TestCaseDefinition&gt; #&gt; 29: &lt;TestCaseDefinition&gt; #&gt; test_case 8.4 Discovering test cases descriptions Any R object instrumented with test case definitions allows for defined test case definitions discovery. retrieveTestCaseDescriptions(AdditionTCFIG1()) #&gt; function_name #&gt; 1: addDouble #&gt; 2: addDouble #&gt; 3: addDouble #&gt; 4: addDouble #&gt; 5: addDouble #&gt; 6: addDouble #&gt; 7: addDouble #&gt; 8: addDouble #&gt; 9: addDouble #&gt; 10: addInteger #&gt; 11: addInteger #&gt; 12: addInteger #&gt; 13: addInteger #&gt; 14: addInteger #&gt; 15: addInteger #&gt; 16: addInteger #&gt; 17: addInteger #&gt; 18: addInteger #&gt; 19: divideByZero #&gt; 20: divideByZero #&gt; 21: divideByZero #&gt; 22: generateWarning #&gt; 23: generateError #&gt; 24: addMultiDouble #&gt; 25: addMultiDouble #&gt; 26: addMultiDouble #&gt; 27: addMultiInteger #&gt; 28: addMultiInteger #&gt; 29: addMultiInteger #&gt; function_name #&gt; description #&gt; 1: sum 2 doubles #&gt; 2: sum 1 double and 1 NA_real_ #&gt; 3: sum 2 NA_real_ #&gt; 4: sum 2 NAN #&gt; 5: sum 2 Inf #&gt; 6: sum 2 as.integers confused with sum of rounded value as expectation #&gt; 7: sum of 1 integer and 1 double #&gt; 8: sum of 1 integer and 1 double #&gt; 9: sum 2 NA #&gt; 10: sum 2 integers #&gt; 11: sum 1 integer and 1 NA_integer #&gt; 12: sum 2 NA_integer #&gt; 13: sum a converted string with one integer #&gt; 14: sum 1 integer and 1 double #&gt; 15: sum 1 integer and 1 Inf #&gt; 16: sum 1 integer and 1 NAN #&gt; 17: sum 1 integer and 1 NA #&gt; 18: sum a vector of 2 integers with 1 integer #&gt; 19: 1 / 0 #&gt; 20: -1 / 0 #&gt; 21: 0 / 0 #&gt; 22: generate warning #&gt; 23: generate error #&gt; 24: sum of 1 integer and 1 double #&gt; 25: sum of 1 double, 2 integers and 1 NA_integer_ #&gt; 26: sum of nothing #&gt; 27: sum of 4 integers #&gt; 28: sum of 1 integer, 2 doubles and 1 NA_integer_ #&gt; 29: sum of one integer and nothing #&gt; description retrieveTestCaseDescriptions(Addition()) #&gt; [1] &quot;provided object owns no test case definitions&quot; 8.5 Run a test case To run a test case, you may use the package function runTestCase. runTestCase(AdditionTCFIG1(), 4, EvaluationMode(defineEvaluationModes()[3])) #&gt; $raw #&gt; $raw$addDouble #&gt; $raw$addDouble$status #&gt; [1] TRUE #&gt; #&gt; $raw$addDouble$value #&gt; [1] NaN #&gt; #&gt; $raw$addDouble$mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $raw$addDouble$function_return_check #&gt; [1] TRUE #&gt; #&gt; $raw$addDouble$parameter_check #&gt; [1] TRUE #&gt; #&gt; $raw$addDouble$parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_d NaN TRUE good type in values #&gt; 2: y_d NaN TRUE good type in values #&gt; #&gt; $raw$addDouble$function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_d NaN TRUE good type in values #&gt; #&gt; $raw$addDouble$index #&gt; [1] 4 #&gt; #&gt; $raw$addDouble$value_check #&gt; [1] TRUE #&gt; #&gt; $raw$addDouble$expected_evaluation #&gt; [1] &quot;correct&quot; #&gt; #&gt; $raw$addDouble$execution_evaluation #&gt; [1] &quot;correct&quot; #&gt; #&gt; $raw$addDouble$failure_origin #&gt; [1] NA #&gt; #&gt; #&gt; #&gt; $synthesis #&gt; status mode index value_check #&gt; 1: TRUE type_checking_enforcement 4 TRUE #&gt; function_return_check parameter_check expected_evaluation #&gt; 1: TRUE TRUE correct #&gt; execution_evaluation failure_origin #&gt; 1: correct &lt;NA&gt; This runs the test number 4. Result has two parts. A raw part, that holds the intermediate computation results, and a synthesis part that is a data.table provided to ease result interpretation. You can provide a vector instead of a single test number if you want to run several use test cases in one call. runTestCase(AdditionTCFIG1(), 12:17, EvaluationMode(defineEvaluationModes()[3])) #&gt; $raw #&gt; $raw$addInteger #&gt; $raw$addInteger$status #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$value #&gt; [1] NA #&gt; #&gt; $raw$addInteger$mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $raw$addInteger$function_return_check #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$parameter_check #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_i NA TRUE good type in values #&gt; 2: y_i NA TRUE good type in values #&gt; #&gt; $raw$addInteger$function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i NA TRUE good type in values #&gt; #&gt; $raw$addInteger$index #&gt; [1] 12 #&gt; #&gt; $raw$addInteger$value_check #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$expected_evaluation #&gt; [1] &quot;correct&quot; #&gt; #&gt; $raw$addInteger$execution_evaluation #&gt; [1] &quot;correct&quot; #&gt; #&gt; $raw$addInteger$failure_origin #&gt; [1] NA #&gt; #&gt; #&gt; $raw$addInteger #&gt; $raw$addInteger$status #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$value #&gt; [1] 89 #&gt; #&gt; $raw$addInteger$mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $raw$addInteger$function_return_check #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$parameter_check #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 45 TRUE good type in values #&gt; 2: y_i 44 TRUE good type in values #&gt; #&gt; $raw$addInteger$function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 89 TRUE good type in values #&gt; #&gt; $raw$addInteger$index #&gt; [1] 13 #&gt; #&gt; $raw$addInteger$value_check #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$expected_evaluation #&gt; [1] &quot;correct&quot; #&gt; #&gt; $raw$addInteger$execution_evaluation #&gt; [1] &quot;correct&quot; #&gt; #&gt; $raw$addInteger$failure_origin #&gt; [1] NA #&gt; #&gt; #&gt; $raw$addInteger #&gt; $raw$addInteger$status #&gt; [1] FALSE #&gt; #&gt; $raw$addInteger$value #&gt; [1] 78.5 #&gt; #&gt; $raw$addInteger$mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $raw$addInteger$function_return_check #&gt; [1] FALSE #&gt; #&gt; $raw$addInteger$parameter_check #&gt; [1] FALSE #&gt; #&gt; $raw$addInteger$parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 34 TRUE good type in values #&gt; 2: y_i 44.5 FALSE wrong type in values #&gt; #&gt; $raw$addInteger$function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 78.5 FALSE wrong type in values #&gt; #&gt; $raw$addInteger$index #&gt; [1] 14 #&gt; #&gt; $raw$addInteger$value_check #&gt; [1] FALSE #&gt; #&gt; $raw$addInteger$expected_evaluation #&gt; [1] &quot;failure&quot; #&gt; #&gt; $raw$addInteger$execution_evaluation #&gt; [1] &quot;failure&quot; #&gt; #&gt; $raw$addInteger$failure_origin #&gt; [1] &quot;function return type check, parameter check&quot; #&gt; #&gt; #&gt; $raw$addInteger #&gt; $raw$addInteger$status #&gt; [1] FALSE #&gt; #&gt; $raw$addInteger$value #&gt; [1] Inf #&gt; #&gt; $raw$addInteger$mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $raw$addInteger$function_return_check #&gt; [1] FALSE #&gt; #&gt; $raw$addInteger$parameter_check #&gt; [1] FALSE #&gt; #&gt; $raw$addInteger$parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 34 TRUE good type in values #&gt; 2: y_i Inf FALSE wrong type in values #&gt; #&gt; $raw$addInteger$function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i Inf FALSE wrong type in values #&gt; #&gt; $raw$addInteger$index #&gt; [1] 15 #&gt; #&gt; $raw$addInteger$value_check #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$expected_evaluation #&gt; [1] &quot;failure&quot; #&gt; #&gt; $raw$addInteger$execution_evaluation #&gt; [1] &quot;failure&quot; #&gt; #&gt; $raw$addInteger$failure_origin #&gt; [1] &quot;function return type check, parameter check&quot; #&gt; #&gt; #&gt; $raw$addInteger #&gt; $raw$addInteger$status #&gt; [1] FALSE #&gt; #&gt; $raw$addInteger$value #&gt; [1] NaN #&gt; #&gt; $raw$addInteger$mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $raw$addInteger$function_return_check #&gt; [1] FALSE #&gt; #&gt; $raw$addInteger$parameter_check #&gt; [1] FALSE #&gt; #&gt; $raw$addInteger$parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 34 TRUE good type in values #&gt; 2: y_i NaN FALSE wrong type in values #&gt; #&gt; $raw$addInteger$function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i NaN FALSE wrong type in values #&gt; #&gt; $raw$addInteger$index #&gt; [1] 16 #&gt; #&gt; $raw$addInteger$value_check #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$expected_evaluation #&gt; [1] &quot;failure&quot; #&gt; #&gt; $raw$addInteger$execution_evaluation #&gt; [1] &quot;failure&quot; #&gt; #&gt; $raw$addInteger$failure_origin #&gt; [1] &quot;function return type check, parameter check&quot; #&gt; #&gt; #&gt; $raw$addInteger #&gt; $raw$addInteger$status #&gt; [1] FALSE #&gt; #&gt; $raw$addInteger$value #&gt; [1] NA #&gt; #&gt; $raw$addInteger$mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $raw$addInteger$function_return_check #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$parameter_check #&gt; [1] FALSE #&gt; #&gt; $raw$addInteger$parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 34 TRUE good type in values #&gt; 2: y_i NA FALSE wrong type in values #&gt; #&gt; $raw$addInteger$function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i NA TRUE good type in values #&gt; #&gt; $raw$addInteger$index #&gt; [1] 17 #&gt; #&gt; $raw$addInteger$value_check #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$expected_evaluation #&gt; [1] &quot;failure&quot; #&gt; #&gt; $raw$addInteger$execution_evaluation #&gt; [1] &quot;failure&quot; #&gt; #&gt; $raw$addInteger$failure_origin #&gt; [1] &quot;parameter check&quot; #&gt; #&gt; #&gt; #&gt; $synthesis #&gt; status mode index value_check #&gt; 1: TRUE type_checking_enforcement 12 TRUE #&gt; 2: TRUE type_checking_enforcement 13 TRUE #&gt; 3: FALSE type_checking_enforcement 14 FALSE #&gt; 4: FALSE type_checking_enforcement 15 TRUE #&gt; 5: FALSE type_checking_enforcement 16 TRUE #&gt; 6: FALSE type_checking_enforcement 17 TRUE #&gt; function_return_check parameter_check expected_evaluation #&gt; 1: TRUE TRUE correct #&gt; 2: TRUE TRUE correct #&gt; 3: FALSE FALSE failure #&gt; 4: FALSE FALSE failure #&gt; 5: FALSE FALSE failure #&gt; 6: TRUE FALSE failure #&gt; execution_evaluation failure_origin #&gt; 1: correct &lt;NA&gt; #&gt; 2: correct &lt;NA&gt; #&gt; 3: failure function return type check, parameter check #&gt; 4: failure function return type check, parameter check #&gt; 5: failure function return type check, parameter check #&gt; 6: failure parameter check Looking at synthesis, you will discover that test 17 fails under chosen evaluation mode, and therefore should require a fix. Here looking at raw results for test number 17, brings solution, that is about input parameter compliance. Provided values are double, whereas integers were expected. "],
["generating-testthat-test-files.html", " 9 Generating testthat test files 9.1 Package wyz.code.testthat in action 9.2 Generated unit test file content 9.3 Known-limits", " 9 Generating testthat test files When your R code is offensive programming instrumented, it becomes possible to generate testthat unit test files, thus improving greatly developers productivity. To be able to generate testthat unit test files, you must ensure that your R code is function return type instrumented and test cases instrumented. Both are required for this generation. 9.1 Package wyz.code.testthat in action 9.1.1 Setting up the context To create testthat unit test files, you must provide a target folder, to store the generated unit test files. In this session, generated files will be stored onto folder generated-testthat. You may change this, but be warned that generated files might be overwritten without any reminder. Be careful, if you set the target folder to tests/testthat as you may loose previous work. You may save frequently your results in configuration management to be able to retrieve original file content whenever required. Here, I reuse 4 files from package wyz.code.offensiveProgramming to generate unit test files from. library(wyz.code.testthat) target_folder &lt;- &#39;generated-testthat&#39; if (!dir.exists(target_folder)) dir.create(target_folder) generateTests &lt;- function(sourceFile_s_1, sourcePackage_s_1, object_o_1) { g &lt;- gautfo(object_o_1, sourceFile_s_1, sourcePackage_s_1, target_folder) print(g) g } source_package &lt;- &#39;wyz.code.offensiveProgramming&#39; source_files &lt;- c( &#39;code-samples/both-defs/good/full/AdditionTCFIG1.R&#39;, &#39;code-samples/no-defs/Addition.R&#39;, &#39;code-samples/frt-defs/good/partial/AdditionFIPartial.R&#39;, &#39;code-samples/tcd-defs/good/partial/AdditionTCPartial.R&#39; ) invisible(sapply(source_files, function(e) { source(system.file(e, package = source_package)) })) 9.1.2 Unit test file generation Generation is done on a per class basis. Simply use function gautfo or function generateAllUnitTestsFromObject. 9.1.2.1 Nominal case Class AdditionTCFIG1 is offensive programming instrumented. It uses both function return type instrumentation and test case instrumentation. Indeed, this class is partially instrumented. Not all the methods of the class have test cases declared for. Generation is quite straightforward. print(gautfo(AdditionTCFIG1(), source_files[1], source_package, target_folder)) #&gt; $class #&gt; [1] &quot;AdditionTCFIG1&quot; #&gt; #&gt; $filenames #&gt; filename overwritten #&gt; 1: generated-testthat/test_AdditionTCFIG1-addDouble.R TRUE #&gt; 2: generated-testthat/test_AdditionTCFIG1-addInteger.R TRUE #&gt; 3: generated-testthat/test_AdditionTCFIG1-divideByZero.R TRUE #&gt; 4: generated-testthat/test_AdditionTCFIG1-generateWarning.R TRUE #&gt; 5: generated-testthat/test_AdditionTCFIG1-generateError.R TRUE #&gt; 6: generated-testthat/test_AdditionTCFIG1-addMultiDouble.R TRUE #&gt; 7: generated-testthat/test_AdditionTCFIG1-addMultiInteger.R TRUE Results is a list with two entries. Entry named filenames holds a data.table providing insight about created files. 9.1.2.2 Exception cases Class Addition is NOT offensive programming instrumented. Class AdditionFIPartial is NOT FULLY offensive programming instrumented. It lacks test cases instrumentation. Class AdditionTCPartial is NOT offensive programming instrumented. It lacks function return type instrumentation. Expected results is no unit test file generation. print(gautfo(Addition(), source_files[2], source_package, target_folder)) #&gt; [1] &quot;Class [Addition] apparently owns no test instrumentation. No test created.&quot; print(gautfo(AdditionFIPartial(), source_files[3], source_package, target_folder)) #&gt; [1] &quot;Class [AdditionFIPartial] apparently owns no test instrumentation. No test created.&quot; print(gautfo(AdditionTCPartial(), source_files[4], source_package, target_folder)) #&gt; [1] &quot;Class [AdditionTCPartial] apparently owns no function return type instrumentation. No test created.&quot; 9.2 Generated unit test file content Typically, generated R code will looks like following unit test code. Note, that comments are provided to ease cross-referencing and to link back easily to wyz.code.offensiveProgramming test case number. This is helpful when facing dysfunctions. source(system.file(&quot;code-samples/both-defs/good/full/AdditionTCFIG1.R&quot;, package = &quot;wyz.code.offensiveProgramming&quot;)) object_o_1 &lt;- AdditionTCFIG1() emsre &lt;- EvaluationMode(&quot;standard_R_evaluation&quot;) rtcsre24 &lt;- runTestCase(object_o_1, 24, emsre) rtcsre25 &lt;- runTestCase(object_o_1, 25, emsre) rtcsre26 &lt;- runTestCase(object_o_1, 26, emsre) test_that(&#39;addMultiDouble&#39;, { # test 24 - sum of 1 integer and 1 double - correct expect_true(rtcsre24$synthesis$status) expect_true(rtcsre24$synthesis$value_check) # test 25 - sum of 1 double, 2 integers and 1 NA_integer_ - correct expect_true(rtcsre25$synthesis$status) expect_true(rtcsre25$synthesis$value_check) # test 26 - sum of nothing - correct expect_true(rtcsre26$synthesis$status) expect_true(rtcsre26$synthesis$value_check) }) emtce &lt;- EvaluationMode(&quot;type_checking_enforcement&quot;) rtctce24 &lt;- runTestCase(object_o_1, 24, emtce) rtctce25 &lt;- runTestCase(object_o_1, 25, emtce) rtctce26 &lt;- runTestCase(object_o_1, 26, emtce) test_that(&#39;addMultiDouble&#39;, { # test 24 - sum of 1 integer and 1 double - correct expect_true(rtctce24$synthesis$status) expect_true(rtctce24$synthesis$value_check) # test 25 - sum of 1 double, 2 integers and 1 NA_integer_ - correct expect_true(rtctce25$synthesis$status) expect_true(rtctce25$synthesis$value_check) # test 26 - sum of nothing - correct expect_true(rtctce26$synthesis$status) expect_true(rtctce26$synthesis$value_check) }) 9.3 Known-limits Generation of unit test file uses meta-programmation based on call function, and aims to produce R valid code. Indeed, format and presentation are not managed, in generated file. Used RStudio editing facilities to ensure nice presentation, although neither mandatory nor required. Generated tests cases are ready to run. Use the standard way to run your testthat test cases onto them. If you face some test failures, verify following points make sure offensive programming evaluation is running fine for ALL evaluation schemes, and that you have no errors at this level make sure your generated test case source is well up to date with the your R offensive programming code. You may regenerate your tests cases at any time if you have any doubt. Note that unit test file generated is fully dependent of your R source and of the instrumented scope. If there are function not instrumented in your source code, do not expect to have unit test cases for them. Also note, when working incrementally, you need to regenerate the unit test cases each time you change the R source code or the offensive programming instrumentation. Best way to put wyz.code.testthat in practice, is to apply following procedure apply offensive programming at the required scope and ensure wyz.code.offensiveProgramming test cases are valid, using runTestCase function generate testthat test cases in one single pass using wyz.code.testthat. To do so, create an R script. This will ease your pain, and will provide consistent results through calls apply testthat testing practice, to verify that generated tests are running fine. "],
["meta-testing.html", " 10 Meta-testing 10.1 Wrapper function creation 10.2 Exploration function 10.3 A more complex example 10.4 An example using ellipsis 10.5 An example with imperative, default and ellipsis arguments 10.6 Pitfalls to avoid", " 10 Meta-testing Meta-testing is the activity aiming to test a function while providing no data to test it. In a R context, it means being able to discover function signature infer data type for each argument generate data set to be used for each argument run the function with generated data sets give back some summary statistics about discoveries of various test run achieved If you try it by hand, you will probably succeed, because the second point will be managed directly by your brain. If you try it by a program, type inference is much trickier, because any argument in R could be of any type. Generally, you need the documentation and explanations to restrict the scope of possible types. That’s where using wyz.code.meta-testing will ease your work and bring instrumentation to get results in a more reliable and quicker way. 10.1 Wrapper function creation Any R function can be classified as offensive programming compliant or not. Second case is indeed much more common and will be encountered more often. In such a case, use offensiveProgrammingWrapFunction or function opwf to generate a new R function that will be offensive programming compliant. You have to provide semantic argument names to this function to be able to generate correctly the wrapping function. Once done, type inference is now driven by semantic argument names. Let’s see a trivial example, considering function cos from base package. library(wyz.code.metaTesting) #&gt; #&gt; Attaching package: &#39;wyz.code.metaTesting&#39; #&gt; The following object is masked from &#39;package:wyz.code.offensiveProgramming&#39;: #&gt; #&gt; packageFunctionsInformation op_cos &lt;- opwf(cos, &#39;radianAngleOrComplex_&#39;) op_cos #&gt; function (radianAngleOrComplex_) #&gt; { #&gt; cos(radianAngleOrComplex_) #&gt; } #&gt; &lt;environment: 0x00000000197a1fa8&gt; You may wonder what are the difference between the two signatures? They share same number of arguments, just the name changed. Yes, but as the name is now a semantic name, it can be managed by a factory See FunctionParameterTypeFactory in wyz.code.offensiveProgramming for more details. 10.2 Exploration function Let’s test base function cos in a traditional way. rt &lt;- tryCatch( lapply(list(2 * pi / 1:9, NA, Inf, 1+1i, list(), letters[1:3]), cos), error = function(e) { print(e); NaN } ) #&gt; Warning in FUN(X[[i]], ...): production de NaN #&gt; &lt;simpleError in FUN(X[[i]], ...): argument non numérique pour une fonction mathématique&gt; And now, we have to unravel the arguments to find which ones are generating warnings or errors, to identify the ones that are accepted. Note that this trial is a gentle trial. It does not try for example to provide raw type or data frame or matrix or a function as argument. If you opt for a more traditionnal approach, then you will have to type as many lines as value types you want to test. This could become really boring very fast, as it disturbates you from the analysis of the results. Let’s test it using wyz.code.meta-testing. First thing do achieve is to get some knowlegde about the function signature complexity. This is easily achieved using function computeArgumentsCombination. computeArgumentsCombination(op_cos) #&gt; $names #&gt; $names$argument #&gt; [1] &quot;radianAngleOrComplex_&quot; #&gt; #&gt; $names$ellipsis #&gt; $names$ellipsis[[1]] #&gt; character(0) #&gt; #&gt; #&gt; $names$default #&gt; $names$default[[1]] #&gt; character(0) #&gt; #&gt; #&gt; #&gt; $number #&gt; $number$argument #&gt; [1] 1 #&gt; #&gt; $number$ellipsis #&gt; [1] 0 #&gt; #&gt; $number$default #&gt; [1] 0 #&gt; #&gt; #&gt; $signatures #&gt; $signatures[[1]] #&gt; [1] &quot;radianAngleOrComplex_&quot; #&gt; #&gt; #&gt; $theoritical_signature_number #&gt; [1] 1 The number of signatures is given by the signatures name. Here there exist only one signature for function op_cos and so for function cos. Note that function computeArgumentsCombination can be used with any R function. It does not requires offensive programming instrumentated function as argument. Let’s test function op_cos. es &lt;- exploreSignatures(op_cos, list(radianAngleOrComplex_ = c(&#39;im&#39;, &#39;r&#39;, &#39;cm&#39;))) print(es$success$synthesis) #&gt; $number_sucessfull_tests #&gt; [1] 6 #&gt; #&gt; $signatures #&gt; [1] &quot;radianAngleOrComplex_&quot; #&gt; #&gt; $imperative #&gt; [1] &quot;{homo,hetero}_{vector}_{one,two,three}&quot; print(es$failure$synthesis) #&gt; $number_erroneous_tests #&gt; [1] 6 #&gt; #&gt; $error #&gt; [1] &quot;Error in cos(radianAngleOrComplex_): argument non numérique pour une fonction mathématique\\n&quot; #&gt; #&gt; $signatures #&gt; [1] &quot;radianAngleOrComplex_&quot; #&gt; #&gt; $imperative #&gt; [1] &quot;{homo,hetero}_{list}_{one,two,three}&quot; The second argument is just type restriction to be enforced. Here I asked for integer real and complex mathematical types these are different from R integer, double and complex as they cannot take value NA. Type restrictions are only considered for polymorphic arguments reminder: the ones that ends with an underscore. Results tell you that same signature brings various results. Here, 6 tests succeeded and 6 failed. It is clear that the issue is tied to using a list as value to an imperative argument you will have to learn how to interpret the synthesis indeed. All execution errors provided the same error message. Looking closer, on success, you see that only vectors provided results. Now, you can conclude that cos functions accepts as input vectors of integers, reals and complex passing a list as argument brings an error with the shown message. To be complete, note that as I enforced mathematical arguments, values NA, NaN and Inf are no more possible values for test. This match the mathematic function cosinus and not the R function cos. This is an important point, know what scope you want to test, not just what function you want to test I do not understand the results when using complex numbers. I was expecting the cosinus of a complex number to compute the cosinus of the argument of the complex number, normalized by its modulus. Was expecting a ℂ to ℝ function. That is clearly not the case as output are complex numbers. That is a ℂ to ℂ function. I am still a taker of any explanation about this. 10.3 A more complex example Let’s now use function append from base package. As you know, we need first to create the offensive programming wrapper function. op_append &lt;- opwf(append, c(&#39;originalValues_&#39;, &#39;valuesToInsert_&#39;, &#39;afterIndex_ui_1&#39;)) op_append #&gt; function (originalValues_, valuesToInsert_, afterIndex_ui_1 = length(originalValues_)) #&gt; { #&gt; append(originalValues_, valuesToInsert_, after = afterIndex_ui_1) #&gt; } #&gt; &lt;environment: 0x000000001a465408&gt; As you can see, parameter substitution is also achieved in code for default arguments. How complex is it to test this function? computeArgumentsCombination(op_append) #&gt; $names #&gt; $names$argument #&gt; [1] &quot;originalValues_&quot; &quot;valuesToInsert_&quot; #&gt; #&gt; $names$ellipsis #&gt; $names$ellipsis[[1]] #&gt; character(0) #&gt; #&gt; #&gt; $names$default #&gt; $names$default[[1]] #&gt; character(0) #&gt; #&gt; $names$default[[2]] #&gt; [1] &quot;afterIndex_ui_1&quot; #&gt; #&gt; #&gt; #&gt; $number #&gt; $number$argument #&gt; [1] 2 #&gt; #&gt; $number$ellipsis #&gt; [1] 0 #&gt; #&gt; $number$default #&gt; [1] 0 1 #&gt; #&gt; #&gt; $signatures #&gt; $signatures[[1]] #&gt; [1] &quot;originalValues_, valuesToInsert_&quot; #&gt; #&gt; $signatures[[2]] #&gt; [1] &quot;originalValues_, valuesToInsert_, afterIndex_ui_1&quot; #&gt; #&gt; #&gt; $theoritical_signature_number #&gt; [1] 2 There are two call signatures, one without default parameter, one with. Let’s test them. es &lt;- exploreSignatures(op_append) print(es$success$synthesis) #&gt; $number_sucessfull_tests #&gt; [1] 24 #&gt; #&gt; $signatures #&gt; [1] &quot;originalValues_, valuesToInsert_&quot; #&gt; [2] &quot;originalValues_, valuesToInsert_, afterIndex_ui_1&quot; #&gt; #&gt; $imperative #&gt; [1] &quot;{homo,hetero}_{vector,list}_{one,two,three}&quot; #&gt; #&gt; $default #&gt; [1] &quot;{none,full}&quot; print(es$failure$synthesis) #&gt; [1] NA From the 24 test runs, no errors where generated. If you are curious about a particular test call, let’s say number 22, just introspect returned values as below. You will see the code use to call the function during the test. print(es$success$code[22]$call_string) #&gt; [1] &quot;op_append(originalValues_ = list(c(-8+3i, 5+6i, -13+3i, 8+1i), --- c(-8-6i, 15+5i, 5+8i, 12-5i)), valuesToInsert_ = list(c(17L, ---11L), list(data = list(list(data = list(as.raw(0x6e), list(data = list(--- list(data = list(c(8+12i, -2-8i), structure(16384, class = \\&quot;Date\\&quot;), --- list(data = list(4+15i, list(data = list(list(data = list(--- 6L, list(data = list(list(data = list(list(data = list(--- c(FALSE, NA, FALSE, NA), list(data = list(-5:-4, --- c(FALSE, NA, NA))), structure(c(972864000, --- 972864000), class = c(\\&quot;POSIXct\\&quot;, \\&quot;POSIXt\\&quot;)), --- c(NA, 1.00412152381614, 1.00412152381614))))), --- list(data = list(c(17L, 14L, 7L, 5L, 2L, 11L), --- list(data = list(list(data = list(2.69039925839752, --- c(-3+9i, -9-16i, 2-15i), c(13.2084962166846, --- 13.3436268009245, 2.62213358655572, 6.90973385795951, --- 7.19652696698904), c(10L, -17L))))), c(8.62264013290405, --- 10.4135163128376, 8.36220926046371, 1.94969380274415, --- 2.62334731966257, 8.64920395612717))))), TRUE, --- list(data = list(list(data = list(TRUE, 7.38372031599283, --- c(-13L, -4L, -9L))), c(-12L, -3L, -2L), list(--- data = list(NA)))), c(7.27329816808924, 3.28533956455067, --- -11.548649426084, -5.39954257849604, -0.158040850423276--- ), c(6L, 9L, 4L))))), list(data = list(8.27031458774582, --- list(data = list(list(data = list(integer(0))))))))), --- c(\\&quot;oxmblc\\&quot;, \\&quot;ppyed\\&quot;, \\&quot;zwiiktp\\&quot;, \\&quot;ppmzgz\\&quot;, \\&quot;roaodslbtts\\&quot;, --- \\&quot;avxw\\&quot;), -15.2460190393031, list(data = list(list(data = list(--- numeric(0), integer(0))), list(data = list(c(\\&quot;wst\\&quot;, --- \\&quot;mvfbyevtob\\&quot;, \\&quot;lmkhwocpf\\&quot;), as.raw(c(0x78, 0x64, 0x68, --- 0x69, 0x77, 0x68)), c(11.9735112781636, -8.66431576246396, --- -15.858928845264), 2L, list(data = list(8L, list(data = list(--- c(\\&quot;viszsesun\\&quot;, \\&quot;flgv\\&quot;, \\&quot;iqpzh\\&quot;, \\&quot;isziiphi\\&quot;, \\&quot;aco\\&quot;, --- \\&quot;vqrufyq\\&quot;), c(NA, 2.33606173284352, -16.2792672854848, --- -16.2792672854848, -2.4392126603052), numeric(0), --- list(data = list(-11.1560563221574)), TRUE, -2.62471943721175)))), --- list(data = list(list(data = list(c(-9.52451307699084, --- -11.9914163388312))), FALSE)))), list(data = list(--- c(-4L, 11L, -1L, -12L, 3L), c(-16L, 17L, -16L, -1L, --- 7L), \\&quot;mfkmdh\\&quot;, numeric(0), list(data = list(list(--- data = list(c(4.92849926324561, 13.471843149513, --- -0.60454114805907), c(10.7167961113155, 7.43848054483533--- ))), c(\\&quot;rxoxh\\&quot;, \\&quot;sihls\\&quot;), complex(0), c(6.67615007981658, --- 8.0937023460865, 13.4478220082819, 13.1799479089677--- ))), list(data = list(c(-4L, 3L), TRUE, list(data = list(--- structure(1466035200, class = c(\\&quot;POSIXct\\&quot;, \\&quot;POSIXt\\&quot;--- )), NA)), list(data = list(list(data = list(c(NA, --- \\&quot;eljucvwdth\\&quot;), FALSE, complex(0), c(11L, 2L, 16L, --- 2L, -15L))), c(-9.51196666806936, -4.35927340388298, --- -7.8687717653811), list(data = list(list(data = list(--- c(4L, 6L, 3L, 7L, 4L), c(TRUE, TRUE), c(1.069873646833, --- -8.54819805454463, -11.9553949269466, -14.8211299027316, --- -8.02534481231123))), c(14L, -5L, 4L, -15L), --- structure(20694, class = \\&quot;Date\\&quot;), c(4.46488302946091, --- -14.9756830153055, -14.9756830153055, -14.9756830153055--- ), c(3.96209045872092, 5.82415194809437, 2.05197109282017--- ))), list(data = list(c(TRUE, FALSE, FALSE, FALSE, --- TRUE), integer(0))))), list(data = list(c(17L, 10L, --- 6L, 13L))))), FALSE)))), c(\\&quot;ifkho\\&quot;, \\&quot;ltts\\&quot;, \\&quot;dazpi\\&quot;, --- \\&quot;ojmli\\&quot;, \\&quot;uuomdhcrm\\&quot;))))))), list(data = list(c(3L, 12L, ---11L))), c(-7+10i, 10-10i, -10+6i, 8-2i), list(data = list(c(-5.65178386494517, ----13.7241868562996, -15.842213910073), FALSE, TRUE, c(-7L, -5L, ----9L, -9L)))))), afterIndex_ui_1 = 17L)&quot; If you desire to introspect the call results, use this approach. print(es$success$code[22]$result) #&gt; [[1]] #&gt; [[1]][[1]] #&gt; [1] -8+3i 5+6i -13+3i 8+1i #&gt; #&gt; [[1]][[2]] #&gt; [1] -8-6i 15+5i 5+8i 12-5i #&gt; #&gt; [[1]][[3]] #&gt; [1] 17 11 #&gt; #&gt; [[1]][[4]] #&gt; [[1]][[4]]$data #&gt; [[1]][[4]]$data[[1]] #&gt; [[1]][[4]]$data[[1]]$data #&gt; [[1]][[4]]$data[[1]]$data[[1]] #&gt; [1] 6e #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[1]] #&gt; [1] 8+12i -2- 8i #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[2]] #&gt; [1] &quot;2014-11-10&quot; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[1]] #&gt; [1] 4+15i #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[1]] #&gt; [1] 6 #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[2]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[2]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[2]]$data[[1]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[2]]$data[[1]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[2]]$data[[1]]$data[[1]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[2]]$data[[1]]$data[[1]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[2]]$data[[1]]$data[[1]]$data[[1]] #&gt; [1] FALSE NA FALSE NA #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[2]]$data[[1]]$data[[1]]$data[[2]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[2]]$data[[1]]$data[[1]]$data[[2]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[2]]$data[[1]]$data[[1]]$data[[2]]$data[[1]] #&gt; [1] -5 -4 #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[2]]$data[[1]]$data[[1]]$data[[2]]$data[[2]] #&gt; [1] FALSE NA NA #&gt; #&gt; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[2]]$data[[1]]$data[[1]]$data[[3]] #&gt; [1] &quot;2000-10-30 01:00:00 CET&quot; &quot;2000-10-30 01:00:00 CET&quot; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[2]]$data[[1]]$data[[1]]$data[[4]] #&gt; [1] NA 1.004122 1.004122 #&gt; #&gt; #&gt; #&gt; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[2]]$data[[2]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[2]]$data[[2]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[2]]$data[[2]]$data[[1]] #&gt; [1] 17 14 7 5 2 11 #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[2]]$data[[2]]$data[[2]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[2]]$data[[2]]$data[[2]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[2]]$data[[2]]$data[[2]]$data[[1]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[2]]$data[[2]]$data[[2]]$data[[1]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[2]]$data[[2]]$data[[2]]$data[[1]]$data[[1]] #&gt; [1] 2.690399 #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[2]]$data[[2]]$data[[2]]$data[[1]]$data[[2]] #&gt; [1] -3+ 9i -9-16i 2-15i #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[2]]$data[[2]]$data[[2]]$data[[1]]$data[[3]] #&gt; [1] 13.208496 13.343627 2.622134 6.909734 7.196527 #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[2]]$data[[2]]$data[[2]]$data[[1]]$data[[4]] #&gt; [1] 10 -17 #&gt; #&gt; #&gt; #&gt; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[2]]$data[[2]]$data[[3]] #&gt; [1] 8.622640 10.413516 8.362209 1.949694 2.623347 8.649204 #&gt; #&gt; #&gt; #&gt; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[3]] #&gt; [1] TRUE #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[4]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[4]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[4]]$data[[1]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[4]]$data[[1]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[4]]$data[[1]]$data[[1]] #&gt; [1] TRUE #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[4]]$data[[1]]$data[[2]] #&gt; [1] 7.38372 #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[4]]$data[[1]]$data[[3]] #&gt; [1] -13 -4 -9 #&gt; #&gt; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[4]]$data[[2]] #&gt; [1] -12 -3 -2 #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[4]]$data[[3]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[4]]$data[[3]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[4]]$data[[3]]$data[[1]] #&gt; [1] NA #&gt; #&gt; #&gt; #&gt; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[5]] #&gt; [1] 7.2732982 3.2853396 -11.5486494 -5.3995426 -0.1580409 #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[2]]$data[[1]]$data[[6]] #&gt; [1] 6 9 4 #&gt; #&gt; #&gt; #&gt; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[3]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[3]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[3]]$data[[1]] #&gt; [1] 8.270315 #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[3]]$data[[2]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[3]]$data[[2]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[3]]$data[[2]]$data[[1]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[3]]$data[[2]]$data[[1]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[3]]$data[[3]]$data[[2]]$data[[1]]$data[[1]] #&gt; integer(0) #&gt; #&gt; #&gt; #&gt; #&gt; #&gt; #&gt; #&gt; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[4]] #&gt; [1] &quot;oxmblc&quot; &quot;ppyed&quot; &quot;zwiiktp&quot; &quot;ppmzgz&quot; &quot;roaodslbtts&quot; #&gt; [6] &quot;avxw&quot; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[5]] #&gt; [1] -15.24602 #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[1]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[1]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[1]]$data[[1]] #&gt; numeric(0) #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[1]]$data[[2]] #&gt; integer(0) #&gt; #&gt; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[2]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[2]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[2]]$data[[1]] #&gt; [1] &quot;wst&quot; &quot;mvfbyevtob&quot; &quot;lmkhwocpf&quot; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[2]]$data[[2]] #&gt; [1] 78 64 68 69 77 68 #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[2]]$data[[3]] #&gt; [1] 11.973511 -8.664316 -15.858929 #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[2]]$data[[4]] #&gt; [1] 2 #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[2]]$data[[5]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[2]]$data[[5]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[2]]$data[[5]]$data[[1]] #&gt; [1] 8 #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[2]]$data[[5]]$data[[2]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[2]]$data[[5]]$data[[2]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[2]]$data[[5]]$data[[2]]$data[[1]] #&gt; [1] &quot;viszsesun&quot; &quot;flgv&quot; &quot;iqpzh&quot; &quot;isziiphi&quot; &quot;aco&quot; &quot;vqrufyq&quot; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[2]]$data[[5]]$data[[2]]$data[[2]] #&gt; [1] NA 2.336062 -16.279267 -16.279267 -2.439213 #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[2]]$data[[5]]$data[[2]]$data[[3]] #&gt; numeric(0) #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[2]]$data[[5]]$data[[2]]$data[[4]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[2]]$data[[5]]$data[[2]]$data[[4]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[2]]$data[[5]]$data[[2]]$data[[4]]$data[[1]] #&gt; [1] -11.15606 #&gt; #&gt; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[2]]$data[[5]]$data[[2]]$data[[5]] #&gt; [1] TRUE #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[2]]$data[[5]]$data[[2]]$data[[6]] #&gt; [1] -2.624719 #&gt; #&gt; #&gt; #&gt; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[2]]$data[[6]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[2]]$data[[6]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[2]]$data[[6]]$data[[1]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[2]]$data[[6]]$data[[1]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[2]]$data[[6]]$data[[1]]$data[[1]] #&gt; [1] -9.524513 -11.991416 #&gt; #&gt; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[2]]$data[[6]]$data[[2]] #&gt; [1] FALSE #&gt; #&gt; #&gt; #&gt; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[1]] #&gt; [1] -4 11 -1 -12 3 #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[2]] #&gt; [1] -16 17 -16 -1 7 #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[3]] #&gt; [1] &quot;mfkmdh&quot; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[4]] #&gt; numeric(0) #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[5]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[5]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[5]]$data[[1]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[5]]$data[[1]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[5]]$data[[1]]$data[[1]] #&gt; [1] 4.9284993 13.4718431 -0.6045411 #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[5]]$data[[1]]$data[[2]] #&gt; [1] 10.716796 7.438481 #&gt; #&gt; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[5]]$data[[2]] #&gt; [1] &quot;rxoxh&quot; &quot;sihls&quot; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[5]]$data[[3]] #&gt; complex(0) #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[5]]$data[[4]] #&gt; [1] 6.676150 8.093702 13.447822 13.179948 #&gt; #&gt; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[1]] #&gt; [1] -4 3 #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[2]] #&gt; [1] TRUE #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[3]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[3]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[3]]$data[[1]] #&gt; [1] &quot;2016-06-16 02:00:00 CEST&quot; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[3]]$data[[2]] #&gt; [1] NA #&gt; #&gt; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[4]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[4]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[4]]$data[[1]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[4]]$data[[1]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[4]]$data[[1]]$data[[1]] #&gt; [1] NA &quot;eljucvwdth&quot; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[4]]$data[[1]]$data[[2]] #&gt; [1] FALSE #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[4]]$data[[1]]$data[[3]] #&gt; complex(0) #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[4]]$data[[1]]$data[[4]] #&gt; [1] 11 2 16 2 -15 #&gt; #&gt; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[4]]$data[[2]] #&gt; [1] -9.511967 -4.359273 -7.868772 #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[4]]$data[[3]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[4]]$data[[3]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[4]]$data[[3]]$data[[1]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[4]]$data[[3]]$data[[1]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[4]]$data[[3]]$data[[1]]$data[[1]] #&gt; [1] 4 6 3 7 4 #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[4]]$data[[3]]$data[[1]]$data[[2]] #&gt; [1] TRUE TRUE #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[4]]$data[[3]]$data[[1]]$data[[3]] #&gt; [1] 1.069874 -8.548198 -11.955395 -14.821130 -8.025345 #&gt; #&gt; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[4]]$data[[3]]$data[[2]] #&gt; [1] 14 -5 4 -15 #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[4]]$data[[3]]$data[[3]] #&gt; [1] &quot;2026-08-29&quot; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[4]]$data[[3]]$data[[4]] #&gt; [1] 4.464883 -14.975683 -14.975683 -14.975683 #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[4]]$data[[3]]$data[[5]] #&gt; [1] 3.962090 5.824152 2.051971 #&gt; #&gt; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[4]]$data[[4]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[4]]$data[[4]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[4]]$data[[4]]$data[[1]] #&gt; [1] TRUE FALSE FALSE FALSE TRUE #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[4]]$data[[4]]$data[[2]] #&gt; integer(0) #&gt; #&gt; #&gt; #&gt; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[5]] #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[5]]$data #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[6]]$data[[5]]$data[[1]] #&gt; [1] 17 10 6 13 #&gt; #&gt; #&gt; #&gt; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[6]]$data[[3]]$data[[7]] #&gt; [1] FALSE #&gt; #&gt; #&gt; #&gt; #&gt; #&gt; [[1]][[4]]$data[[1]]$data[[2]]$data[[1]]$data[[7]] #&gt; [1] &quot;ifkho&quot; &quot;ltts&quot; &quot;dazpi&quot; &quot;ojmli&quot; &quot;uuomdhcrm&quot; #&gt; #&gt; #&gt; #&gt; #&gt; #&gt; #&gt; #&gt; [[1]][[4]]$data[[2]] #&gt; [[1]][[4]]$data[[2]]$data #&gt; [[1]][[4]]$data[[2]]$data[[1]] #&gt; [1] 3 12 11 #&gt; #&gt; #&gt; #&gt; [[1]][[4]]$data[[3]] #&gt; [1] -7+10i 10-10i -10+ 6i 8- 2i #&gt; #&gt; [[1]][[4]]$data[[4]] #&gt; [[1]][[4]]$data[[4]]$data #&gt; [[1]][[4]]$data[[4]]$data[[1]] #&gt; [1] -5.651784 -13.724187 -15.842214 #&gt; #&gt; [[1]][[4]]$data[[4]]$data[[2]] #&gt; [1] FALSE #&gt; #&gt; [[1]][[4]]$data[[4]]$data[[3]] #&gt; [1] TRUE #&gt; #&gt; [[1]][[4]]$data[[4]]$data[[4]] #&gt; [1] -7 -5 -9 -9 10.4 An example using ellipsis Let’s now use function sum from base package. As you know, we need first to create the offensive programming wrapper function. op_sum &lt;- opwf(sum, c(&#39;...&#39;, &#39;removeNAValues_b_1&#39;)) op_sum #&gt; function (..., removeNAValues_b_1 = FALSE) #&gt; { #&gt; sum(..., na.rm = removeNAValues_b_1) #&gt; } #&gt; &lt;environment: 0x0000000019c87408&gt; As you can see, parameter substitution is also achieved in code for default arguments. How complex is it to test this function? cac_sum &lt;- computeArgumentsCombination(op_sum) print(cac_sum) #&gt; $names #&gt; $names$argument #&gt; character(0) #&gt; #&gt; $names$ellipsis #&gt; $names$ellipsis[[1]] #&gt; character(0) #&gt; #&gt; $names$ellipsis[[2]] #&gt; [1] &quot;ellipsis1_&quot; #&gt; #&gt; $names$ellipsis[[3]] #&gt; [1] &quot;ellipsis1_, ellipsis2_&quot; #&gt; #&gt; $names$ellipsis[[4]] #&gt; [1] &quot;ellipsis1_, ellipsis2_, ellipsis3_&quot; #&gt; #&gt; #&gt; $names$default #&gt; $names$default[[1]] #&gt; character(0) #&gt; #&gt; $names$default[[2]] #&gt; [1] &quot;removeNAValues_b_1&quot; #&gt; #&gt; #&gt; #&gt; $number #&gt; $number$argument #&gt; [1] 0 #&gt; #&gt; $number$ellipsis #&gt; [1] 0 1 2 3 #&gt; #&gt; $number$default #&gt; [1] 0 1 #&gt; #&gt; #&gt; $signatures #&gt; $signatures[[1]] #&gt; character(0) #&gt; #&gt; $signatures[[2]] #&gt; [1] &quot;removeNAValues_b_1&quot; #&gt; #&gt; $signatures[[3]] #&gt; [1] &quot;ellipsis1_&quot; #&gt; #&gt; $signatures[[4]] #&gt; [1] &quot;ellipsis1_, removeNAValues_b_1&quot; #&gt; #&gt; $signatures[[5]] #&gt; [1] &quot;ellipsis1_, ellipsis2_&quot; #&gt; #&gt; $signatures[[6]] #&gt; [1] &quot;ellipsis1_, ellipsis2_, removeNAValues_b_1&quot; #&gt; #&gt; $signatures[[7]] #&gt; [1] &quot;ellipsis1_, ellipsis2_, ellipsis3_&quot; #&gt; #&gt; $signatures[[8]] #&gt; [1] &quot;ellipsis1_, ellipsis2_, ellipsis3_, removeNAValues_b_1&quot; #&gt; #&gt; #&gt; $theoritical_signature_number #&gt; [1] 8 There are eight call signatures, four without default parameter, four with. By default, ellipsis is replaced by 0 to three arguments. That’s why, first signature is empty, and the total is 8. Let’s test them. es &lt;- exploreSignatures(op_sum) print(es$success$synthesis) #&gt; $number_sucessfull_tests #&gt; [1] 8 #&gt; #&gt; $signatures #&gt; [1] &quot;no argument signature&quot; &quot;removeNAValues_b_1&quot; #&gt; #&gt; $ellipsis #&gt; [1] &quot;{homo,hetero}_{vector,list}_{none}&quot; #&gt; #&gt; $default #&gt; [1] &quot;{none,full}&quot; print(es$failure$synthesis) #&gt; $number_erroneous_tests #&gt; [1] 24 #&gt; #&gt; $error #&gt; [1] &quot;Error in sum(..., na.rm = removeNAValues_b_1): &#39;type&#39; (list) de l&#39;argument incorrect\\n&quot; #&gt; #&gt; $signatures #&gt; [1] &quot;ellipsis1_&quot; #&gt; [2] &quot;ellipsis1_, removeNAValues_b_1&quot; #&gt; [3] &quot;ellipsis1_, ellipsis2_&quot; #&gt; [4] &quot;ellipsis1_, ellipsis2_, removeNAValues_b_1&quot; #&gt; [5] &quot;ellipsis1_, ellipsis2_, ellipsis3_&quot; #&gt; [6] &quot;ellipsis1_, ellipsis2_, ellipsis3_, removeNAValues_b_1&quot; #&gt; #&gt; $ellipsis #&gt; [1] &quot;{homo,hetero}_{vector,list}_{one,two,three}&quot; #&gt; #&gt; $default #&gt; [1] &quot;{none,full}&quot; From the 32 test runs, 8 passed, 24 failed. As we gave no restriction types for ellipsis, it has been replaced by any kind of characters, and in particular some that cannot fit a sum. Let’s restrict the types to uses and run again same kind of test. es2 &lt;- exploreSignatures(op_sum, list(&#39;...&#39; = c(&#39;im&#39;, &#39;rm&#39;, &#39;cm&#39;))) Much better. Still 32 tests, now 20 passed, 12 failed. Why? print(es2$failure$synthesis) #&gt; $number_erroneous_tests #&gt; [1] 12 #&gt; #&gt; $error #&gt; [1] &quot;Error in sum(..., na.rm = removeNAValues_b_1): &#39;type&#39; (list) de l&#39;argument incorrect\\n&quot; #&gt; #&gt; $signatures #&gt; [1] &quot;ellipsis1_&quot; #&gt; [2] &quot;ellipsis1_, removeNAValues_b_1&quot; #&gt; [3] &quot;ellipsis1_, ellipsis2_&quot; #&gt; [4] &quot;ellipsis1_, ellipsis2_, removeNAValues_b_1&quot; #&gt; [5] &quot;ellipsis1_, ellipsis2_, ellipsis3_&quot; #&gt; [6] &quot;ellipsis1_, ellipsis2_, ellipsis3_, removeNAValues_b_1&quot; #&gt; #&gt; $ellipsis #&gt; [1] &quot;{homo,hetero}_{list}_{one,two,three}&quot; #&gt; #&gt; $default #&gt; [1] &quot;{none,full}&quot; All failures seems to be related to arguments passed as list. 10.5 An example with imperative, default and ellipsis arguments Let’s now use function kronecker from base package. As you know, we need first to create the offensive programming wrapper function. op_kronecker &lt;- opwf(kronecker, c(&#39;arrayA_a_1&#39;, &#39;arrayB_a_1&#39;, &#39;function_f_1&#39;, &#39;computeDimensionNames_b_1&#39;, &#39;...&#39;)) op_kronecker #&gt; function (arrayA_a_1, arrayB_a_1, function_f_1 = &quot;*&quot;, computeDimensionNames_b_1 = FALSE, #&gt; ...) #&gt; { #&gt; kronecker(arrayA_a_1, arrayB_a_1, FUN = function_f_1, make.dimnames = computeDimensionNames_b_1, #&gt; ...) #&gt; } #&gt; &lt;environment: 0x00000000177c2b90&gt; How complex is it to test this function? cac_kronecker &lt;- computeArgumentsCombination(op_kronecker) print(cac_kronecker) #&gt; $names #&gt; $names$argument #&gt; [1] &quot;arrayA_a_1&quot; &quot;arrayB_a_1&quot; #&gt; #&gt; $names$ellipsis #&gt; $names$ellipsis[[1]] #&gt; character(0) #&gt; #&gt; $names$ellipsis[[2]] #&gt; [1] &quot;ellipsis1_&quot; #&gt; #&gt; $names$ellipsis[[3]] #&gt; [1] &quot;ellipsis1_, ellipsis2_&quot; #&gt; #&gt; $names$ellipsis[[4]] #&gt; [1] &quot;ellipsis1_, ellipsis2_, ellipsis3_&quot; #&gt; #&gt; #&gt; $names$default #&gt; $names$default[[1]] #&gt; character(0) #&gt; #&gt; $names$default[[2]] #&gt; [1] &quot;function_f_1&quot; #&gt; #&gt; $names$default[[3]] #&gt; [1] &quot;computeDimensionNames_b_1&quot; #&gt; #&gt; $names$default[[4]] #&gt; [1] &quot;function_f_1, computeDimensionNames_b_1&quot; #&gt; #&gt; #&gt; #&gt; $number #&gt; $number$argument #&gt; [1] 2 #&gt; #&gt; $number$ellipsis #&gt; [1] 0 1 2 3 #&gt; #&gt; $number$default #&gt; [1] 0 1 2 #&gt; #&gt; #&gt; $signatures #&gt; $signatures[[1]] #&gt; [1] &quot;arrayA_a_1, arrayB_a_1&quot; #&gt; #&gt; $signatures[[2]] #&gt; [1] &quot;arrayA_a_1, arrayB_a_1, ellipsis1_&quot; #&gt; #&gt; $signatures[[3]] #&gt; [1] &quot;arrayA_a_1, arrayB_a_1, ellipsis1_, ellipsis2_&quot; #&gt; #&gt; $signatures[[4]] #&gt; [1] &quot;arrayA_a_1, arrayB_a_1, ellipsis1_, ellipsis2_, ellipsis3_&quot; #&gt; #&gt; $signatures[[5]] #&gt; [1] &quot;arrayA_a_1, arrayB_a_1, computeDimensionNames_b_1&quot; #&gt; #&gt; $signatures[[6]] #&gt; [1] &quot;arrayA_a_1, arrayB_a_1, computeDimensionNames_b_1, ellipsis1_&quot; #&gt; #&gt; $signatures[[7]] #&gt; [1] &quot;arrayA_a_1, arrayB_a_1, computeDimensionNames_b_1, ellipsis1_, ellipsis2_&quot; #&gt; #&gt; $signatures[[8]] #&gt; [1] &quot;arrayA_a_1, arrayB_a_1, computeDimensionNames_b_1, ellipsis1_, ellipsis2_, ellipsis3_&quot; #&gt; #&gt; $signatures[[9]] #&gt; [1] &quot;arrayA_a_1, arrayB_a_1, function_f_1&quot; #&gt; #&gt; $signatures[[10]] #&gt; [1] &quot;arrayA_a_1, arrayB_a_1, function_f_1, ellipsis1_&quot; #&gt; #&gt; $signatures[[11]] #&gt; [1] &quot;arrayA_a_1, arrayB_a_1, function_f_1, ellipsis1_, ellipsis2_&quot; #&gt; #&gt; $signatures[[12]] #&gt; [1] &quot;arrayA_a_1, arrayB_a_1, function_f_1, ellipsis1_, ellipsis2_, ellipsis3_&quot; #&gt; #&gt; $signatures[[13]] #&gt; [1] &quot;arrayA_a_1, arrayB_a_1, function_f_1, computeDimensionNames_b_1&quot; #&gt; #&gt; $signatures[[14]] #&gt; [1] &quot;arrayA_a_1, arrayB_a_1, function_f_1, computeDimensionNames_b_1, ellipsis1_&quot; #&gt; #&gt; $signatures[[15]] #&gt; [1] &quot;arrayA_a_1, arrayB_a_1, function_f_1, computeDimensionNames_b_1, ellipsis1_, ellipsis2_&quot; #&gt; #&gt; $signatures[[16]] #&gt; [1] &quot;arrayA_a_1, arrayB_a_1, function_f_1, computeDimensionNames_b_1, ellipsis1_, ellipsis2_, ellipsis3_&quot; #&gt; #&gt; #&gt; $theoritical_signature_number #&gt; [1] 16 There are sixteen call signatures. Let’s try brut force analysis first. tryCatch(es &lt;- exploreSignatures(op_kronecker), error = function(e) print(e) ) #&gt; &lt;simpleError in abort(&quot;no draw function associated with&quot;, strBracket(value_s_1[1])): no draw function associated with [a]&gt; This fails as there exist no data generation function provided for array. We have to provide one. wrong_draw_integer_array &lt;- function(n, replace_b_1 = TRUE) { m &lt;- n + sample(0:3, 1) matrix(seq(1, n * m), byrow = TRUE, nrow = n, dimnames = list(paste(&#39;row_&#39;, 1:n), paste(&#39;col_&#39;, 1:m))) } # wrong because it does not respect argument names that must be # n_i_1 and replace_b_1 df &lt;- DataFactory() df$addSuffix(&#39;a&#39;, &#39;array&#39;, wrong_draw_integer_array) #&gt; [1] FALSE draw_integer_array &lt;- function(n_i_1, replace_b_1 = TRUE) { m &lt;- n_i_1 + sample(0:3, 1) matrix(seq(1, n_i_1 * m), byrow = TRUE, nrow = n_i_1, dimnames = list(paste(&#39;row_&#39;, 1:n_i_1), paste(&#39;col_&#39;, 1:m))) } draw_function &lt;- function(n_i_1, replace_b_1 = TRUE) { list(`*`, `+`, `-`)[[sample(1:3, 1)]]} # good practice verifies your functions behave correctly on a single example a1 &lt;- draw_integer_array(2) a2 &lt;- draw_integer_array(3) f &lt;- draw_function(1) kronecker(a1, a2, f, TRUE) #&gt; col_ 1:col_ 1 col_ 1:col_ 2 col_ 1:col_ 3 col_ 1:col_ 4 #&gt; row_ 1:row_ 1 2 3 4 5 #&gt; row_ 1:row_ 2 6 7 8 9 #&gt; row_ 1:row_ 3 10 11 12 13 #&gt; row_ 2:row_ 1 5 6 7 8 #&gt; row_ 2:row_ 2 9 10 11 12 #&gt; row_ 2:row_ 3 13 14 15 16 #&gt; col_ 2:col_ 1 col_ 2:col_ 2 col_ 2:col_ 3 col_ 2:col_ 4 #&gt; row_ 1:row_ 1 3 4 5 6 #&gt; row_ 1:row_ 2 7 8 9 10 #&gt; row_ 1:row_ 3 11 12 13 14 #&gt; row_ 2:row_ 1 6 7 8 9 #&gt; row_ 2:row_ 2 10 11 12 13 #&gt; row_ 2:row_ 3 14 15 16 17 #&gt; col_ 3:col_ 1 col_ 3:col_ 2 col_ 3:col_ 3 col_ 3:col_ 4 #&gt; row_ 1:row_ 1 4 5 6 7 #&gt; row_ 1:row_ 2 8 9 10 11 #&gt; row_ 1:row_ 3 12 13 14 15 #&gt; row_ 2:row_ 1 7 8 9 10 #&gt; row_ 2:row_ 2 11 12 13 14 #&gt; row_ 2:row_ 3 15 16 17 18 # register functions df$addSuffix(&#39;a&#39;, &#39;array&#39;, draw_integer_array) #&gt; [1] TRUE df$addSuffix(&#39;f&#39;, &#39;function&#39;, draw_function) #&gt; [1] TRUE # make your factory findable Sys.setenv(&quot;OP_DATA_FACTORY&quot; = &quot;df&quot;) # fire tests - up to 768 contexts managed in one shot es &lt;- exploreSignatures(op_kronecker) print(es$success$synthesis) #&gt; $number_sucessfull_tests #&gt; [1] 144 #&gt; #&gt; $signatures #&gt; [1] &quot;arrayA_a_1, arrayB_a_1&quot; #&gt; [2] &quot;arrayA_a_1, arrayB_a_1, function_f_1, computeDimensionNames_b_1&quot; #&gt; #&gt; $imperative #&gt; [1] &quot;{homo,hetero}_{vector,list}_{one,two,three}&quot; #&gt; #&gt; $ellipsis #&gt; [1] &quot;{homo,hetero}_{vector,list}_{none}&quot; #&gt; #&gt; $default #&gt; [1] &quot;{none,partial,full}&quot; print(es$failure$synthesis) #&gt; $number_erroneous_tests #&gt; [1] 432 #&gt; #&gt; $error #&gt; [1] &quot;Error in outer(X, Y, FUN, ...): using ... with FUN = \\&quot;*\\&quot; is an error\\n&quot; #&gt; [2] &quot;Error in FUN(X, Y, ...): l&#39;opérateur a besoin d&#39;un ou de deux arguments\\n&quot; #&gt; #&gt; $signatures #&gt; [1] &quot;arrayA_a_1, arrayB_a_1, ellipsis1_&quot; #&gt; [2] &quot;arrayA_a_1, arrayB_a_1, function_f_1, computeDimensionNames_b_1, ellipsis1_&quot; #&gt; [3] &quot;arrayA_a_1, arrayB_a_1, ellipsis1_, ellipsis2_&quot; #&gt; [4] &quot;arrayA_a_1, arrayB_a_1, function_f_1, computeDimensionNames_b_1, ellipsis1_, ellipsis2_&quot; #&gt; [5] &quot;arrayA_a_1, arrayB_a_1, ellipsis1_, ellipsis2_, ellipsis3_&quot; #&gt; [6] &quot;arrayA_a_1, arrayB_a_1, function_f_1, computeDimensionNames_b_1, ellipsis1_, ellipsis2_, ellipsis3_&quot; #&gt; #&gt; $imperative #&gt; [1] &quot;{homo,hetero}_{vector,list}_{one,two,three}&quot; #&gt; #&gt; $ellipsis #&gt; [1] &quot;{homo,hetero}_{vector,list}_{one,two,three}&quot; #&gt; #&gt; $default #&gt; [1] &quot;{none,partial,full}&quot; 10.6 Pitfalls to avoid When using opwf function, make sure you provide the argument names in the right order. Examine created function signature prior going further. Make sure it fits the desired definition you look for. DataFactory changes remain invisible to processing as long as you do not set the environment variable OP_DATA_FACTORY with the name of the R variable that holds the DataFactory you want to use. This is often forgotten. "],
["generating-r-documentation.html", " 11 Generating R documentation 11.1 Automated R documentation generation 11.2 Focus on R documentation generation 11.3 package wyz.code.rdoc utilities 11.4 Manual pages generation 11.5 Known-limits 11.6 Opportunities", " 11 Generating R documentation When your code uses offensive programming features, it becomes much easier to generate R documentation, as now, several information might be deduced and reused for manual pages composition. Let’s see how. 11.1 Automated R documentation generation Using package wyz.code.rdoc, manual pages .Rd files stored in man folder in a package context can be automatically created and filled up nearly to completion, depending on the level of offensive programming instrumentation of your code. Generated manual pages uses English language. Feel free to modify produced English, to match your own English flavor, if needed. The level of your R code instrumentation will impact the quality of the generation and your review work depth and time. When using both function return type instrumentation and test case instrumentation, expects produced manual page content to be fully generated and ready for review. No automated generation of manual page is possible when your code is not offensive programming instrumented. In such a case, rely either on standard R tools to generate documentation or use package wyz.code.rdoc to create the artifact program that will reduce the burden of documentation generation. 11.2 Focus on R documentation generation Package wyz.code.rdoc generates manual page sections, presented below with their information source and your remaining duties. R manual section information source your duty name R code none alias R code none, unless you want to add extraneous aliases title R code none usage R code none arguments R code none value R code none if your code is function return type instrumented. Otherwise, you will have to write explicitly this part. details R code you may complete this part that is generated when your code is function test case instrumented. references your instruction Generated from instructions you may provide. author package DESCRIPTION none seealso your instruction Generated from instructions you may provide. keyword your instruction Generated from instructions you may provide. examples R code none when your code is function test case instrumented. concept your instruction Generated from instructions you may provide. Missing sections can be added on your instruction when generating manual pages. Package wyz.code.rdoc provides a convenient and easy way to do so. The generated manual page can be used as-is, and should be immediately viewable and usable. From a format point of view, it complies with .Rd file syntax. From a content point of view, generated content aims to be reliable and express in human readable English wherever this makes sense. Indeed, you may bring desired enhancements to generated English sentences as you want. Generated manual page requires review. You may add extraneous content, modify provided content and beautify the result. See known limits section 9.3 to know more. 11.3 package wyz.code.rdoc utilities The package wyz.code.rdoc can be used to produce R documentation parts and R documentation generation programs. Here under are presented a few utilities that will greatly help you in producing high quality manual pages. Please, take time to read the full paragraph as it will mind you about some very convenient R functions to produces R code documentation snippets. For more information, refer to respective manual pages. 11.3.1 Generate a R documentation section Use function generateSection to generate a standard manual page section. Provide section name as first argument, and content as second. library(wyz.code.rdoc) print(generateSection(&#39;note&#39;, &#39;A note text.&#39;)) #&gt; [1] &quot;\\\\note{\\nA note text.\\n}&quot; This function does not allow you to generate a customized non standard manual page section. To do so, use generateContent. 11.3.2 Format an English sentence Use function sentensize to format a sentence. sentensize(&#39;some text \\t\\b will \\n\\b be generated&#39;) #&gt; [1] &quot;Some text will be generated.&quot; This functions ensures sentence starts with an upper-cased letter, adds a final dot if missing, and normalizes spaces, to ease readability. 11.3.3 Generate some R documentation content Use function generateContent to generate some R documentation content. Beware, as argument order is opposite to the one used for generateSection. print(generateContent(&#39;a title&#39;, &#39;title&#39;)) #&gt; [1] &quot;\\\\title{a title}&quot; print(generateContent(&#39;https://neonira.github.io/offensiveProgrammingBook/&#39;, &#39;href&#39;, &#39;Offensive Programming Book&#39;)) #&gt; [1] &quot;\\\\href{https://neonira.github.io/offensiveProgrammingBook/}{Offensive Programming Book}&quot; print(generateContent(&#39;warning&#39;, &#39;section&#39;, &#39;Warning section content ...&#39;)) #&gt; [1] &quot;\\\\section{warning}{\\nWarning section content ...\\n}&quot; print(generateContent(&#39;a&#39;, &#39;item&#39;, &#39;description of a&#39;, useSpace_b_1 = TRUE)) #&gt; [1] &quot;\\\\item{a} {description of a}&quot; print(generateContent(&#39;a&#39;, &#39;item&#39;, &#39;description of a&#39;, useSpace_b_1 = FALSE)) #&gt; [1] &quot;\\\\item{a}{description of a}&quot; 11.3.4 Generate cross-ref to other R package Use function generateSpecialLink to generate a R documentation cross-ref to any other R package. print(generateSpecialLink(&#39;wyz.code.offensiveProgramming&#39;, &#39;runTransientFunction&#39;)) #&gt; [1] &quot;\\\\link[wyz.code.offensiveProgramming:runTransientFunction]{wyz.code.offensiveProgramming:runTransientFunction}&quot; 11.4 Manual pages generation Simply use generateDocumentationContent to do so. 11.4.1 Context setup I will reuse some classes delivered with wyz.code.offensiveProgramming to ease demonstration of R documentation generation. target_folder &lt;- &#39;man&#39; #&quot;~/tmp/generated-doc&quot; if (!dir.exists(target_folder)) dir.create(target_folder) source_package &lt;- &#39;wyz.code.offensiveProgramming&#39; source_files &lt;- c( &#39;code-samples/both-defs/good/full/AdditionTCFIG1.R&#39;, &#39;code-samples/no-defs/Addition.R&#39;, &#39;code-samples/frt-defs/good/partial/AdditionFIPartial.R&#39;, &#39;code-samples/tcd-defs/good/partial/AdditionTCPartial.R&#39; ) invisible(sapply(source_files, function(e) { source(system.file(e, package = source_package)) })) 11.4.2 Method manual page Use keyword method to generate a dedicated manual page for an S3 method. object &lt;- AdditionTCFIG1() package_name &lt;- &#39;zorg&#39; refs &lt;- list( list(url = &#39;https://cran.r-project.org/doc/manuals/R-exts.html&#39;, label = &#39;Writing R extensions&#39;, comment = &#39;to know more about R documentation requirements&#39;), list(url = &#39;https://www.burns-stat.com/pages/Tutor/R_inferno.pdf&#39;, label = &#39;The R Inferno&#39;, comment = &#39;to discover some well-known R weirdness&#39;) ) extra_method &lt;- list( keyword = c(&#39;classes&#39;, &#39;environment&#39;, &#39;utilities&#39;, &#39;misc&#39;), concept = c(&#39;evaluation mode&#39;, &#39;standard evaluation&#39;, &#39;function return type evaluation&#39;, &#39;parameter check evaluation&#39;), references = c(sentensize(paste(&#39;see&#39;, generateContent(&#39;wyz.code.offensiveProgramming&#39;, &#39;code&#39;), &#39;package documentation&#39;)), &#39;&#39;, sentensize(paste(&#39;You may read&#39;, generateContent(&#39;https://neonira.github.io/offensiveProgrammingBook/&#39;, &#39;href&#39;, &#39;Offensive Programming Book&#39;), &#39;to get introduction and expert advices on offensive programming&#39;)), &#39;&#39;, generateReference(refs[[1]]) ), seealso = c(sentensize(paste(&#39;see&#39;, generateContent(generateSpecialLink(&#39;wyz.code.offensiveProgramming&#39;, &#39;runTransientFunction&#39;), &#39;code&#39;), &#39;to call interactively an offensive programming function, whether instrumented or not.&#39;)), &#39;&#39;, sentensize(paste(&#39;see&#39;, generateContent(generateSpecialLink(&#39;wyz.code.offensiveProgramming&#39;, &#39;runTestCase&#39;), &#39;code&#39;), &#39;to reuse on-demand instrumented offensive programming function tests&#39;)) ) ) # explicit invocation for method generateDocumentationContent(target_folder, &#39;method&#39;, &#39;addMultiDouble&#39;, object, package_name, extra_method, overwrite_b_1 = TRUE) Note how parameter extra_method allows you to provide specific content as instruction to be considered for manual page generation. The extraneous content must be a list, where names are manual page sections, and where content is R documentation content. You may use function generateDocumentationContent to generate your own R documentation generation scripts. This allows you to generate programmatically your manual pages, in a customized way. Note that parameter package_name is the name of the target package you want to generate documentation for. Here, files are taken from the wyz.code.offensiveProgramming package, and documentation is generated for package zorg. Really useful when programming, not so useful when used interactively. 11.4.3 Class manual page Use keyword class to create a manual page for a class. Provide the class name. extra_class &lt;- extra_method extra_class$references &lt;- extra_method$references[[5]] extra_class$seealso &lt;- NULL generateDocumentationContent(target_folder, &#39;class&#39;, &#39;AdditionTCFIG1&#39;, object, package_name, extra_class, overwrite_b_1 = TRUE) 11.4.4 Package manual page Use keyword class to generate a summary manual page for your package. Provide explicitly, all the class names you desired to emphase over. extra_package &lt;- extra_method extra_package$seealso &lt;- NULL extra_package$content &lt;- c(&#39;AdditionTCFIG1&#39;, &#39;AdditionTCFIP&#39;, &#39;Addition&#39;) z &lt;- generateDocumentationContent(target_folder, &#39;package&#39;, package_name, object, package_name, extra_package, overwrite_b_1 = TRUE) Result is \\name{zorg-package} \\alias{zorg-package} \\alias{zorg} \\docType{package} \\title{\\packageTitle{zorg}} \\description{ \\packageDescription{zorg} } \\details{ Most important package entries are \\itemize{ \\item{\\code{\\link{AdditionTCFIG1}}}{} \\item{\\code{\\link{AdditionTCFIP}}}{} \\item{\\code{\\link{Addition}}}{} } } \\references{ See \\code{wyz.code.offensiveProgramming} package documentation. You may read \\href{https://neonira.github.io/offensiveProgrammingBook/}{Offensive Programming Book} to get introduction and expert advices on offensive programming. Refer to \\href{https://cran.r-project.org/doc/manuals/R-exts.html}{Writing R extensions} to know more about R documentation requirements. } \\author{ \\packageAuthor{zorg} Maintainer: \\packageMaintainer{zorg} } \\keyword{classes} \\keyword{environment} \\keyword{utilities} \\keyword{misc} \\concept{evaluation mode} \\concept{standard evaluation} \\concept{function return type evaluation} \\concept{parameter check evaluation} 11.4.5 In one shot To simplify your life, you can create in one shot all the manual pages related to methods of a class. Simply pass NA as value for the name. generateDocumentationContent(target_folder, &#39;method&#39;, NA, AdditionTCPartial(), package_name, extra_method, overwrite_b_1 = TRUE) #&gt; $addDouble #&gt; $addDouble$filename #&gt; [1] &quot;man/addDouble.AdditionTCPartial.Rd&quot; #&gt; #&gt; $addDouble$overwritten #&gt; [1] TRUE #&gt; #&gt; #&gt; $addInteger #&gt; $addInteger$filename #&gt; [1] &quot;man/addInteger.AdditionTCPartial.Rd&quot; #&gt; #&gt; $addInteger$overwritten #&gt; [1] TRUE #&gt; #&gt; #&gt; $addNumeric #&gt; $addNumeric$filename #&gt; [1] &quot;man/addNumeric.AdditionTCPartial.Rd&quot; #&gt; #&gt; $addNumeric$overwritten #&gt; [1] TRUE #&gt; #&gt; #&gt; $divideByZero #&gt; $divideByZero$filename #&gt; [1] &quot;man/divideByZero.AdditionTCPartial.Rd&quot; #&gt; #&gt; $divideByZero$overwritten #&gt; [1] TRUE #&gt; #&gt; #&gt; $generateError #&gt; $generateError$filename #&gt; [1] &quot;man/generateError.AdditionTCPartial.Rd&quot; #&gt; #&gt; $generateError$overwritten #&gt; [1] TRUE #&gt; #&gt; #&gt; $generateWarning #&gt; $generateWarning$filename #&gt; [1] &quot;man/generateWarning.AdditionTCPartial.Rd&quot; #&gt; #&gt; $generateWarning$overwritten #&gt; [1] TRUE 11.4.6 and a special case, from a standalone function When you own an offensive programming instrumented function, it is quite easy to get a pre-filled R documentation file from it. Be sure to pass NULL as value for parameter object_o_1. sumValues &lt;- function(x_i, y_i) sum(x_i, y_i, na.rm = TRUE) gmf &lt;- generateDocumentationContent(target_folder, &#39;method&#39;, &#39;sumValues&#39;, NULL, package_name, extra_method, overwrite_b_1 = TRUE) print(gmf) #&gt; $filename #&gt; [1] &quot;man/sumValues.Rd&quot; #&gt; #&gt; $overwritten #&gt; [1] TRUE Indeed, this convenience suffers from two drawbacks As the return type of the function is unknown, value section cannot be documented, As they are no test case definitions, examples section cannot be documented 11.5 Known-limits Generation of manual pages can be quite tricky. Whereas package wyz.code.rdoc alleviates greatly the burden, some pitfalls remain. Here they are Generated manual page might not respect the maximum line length required by R CMD check, and this tool will provide explicit information about un-compliance. To solve issue, just split the content by adding carriage return wherever required. Generated documentation is quite stereotyped. Inject your instruction to customize the result. 11.6 Opportunities Reuse can be made at several levels depending of your needs. Roughly speeking, you maty aim for one of these 3 levels of customization 1. just customize some textual information. Generate the pages using package wyz.code.rdoc and modify page contents manually is generally the best way to achieve this goal 1. customize some manual pages sections. Generate the pages using package wyz.code.rdoc while providing some dedicated context information. Refer to previous examples, and look at variables starting with extra_. They allow you to inject your customized content in targeted sections. 1. If you seek for fully customized manual page generation, then you may use package (ref:rd) to create your own R generation scheme. That way you will get the benefit of starting launched, using high-level R documentation generation functions, and also get the ability to reuse and customized provided generation scheme. This package uses only R code, and so you could get insight and reuse any part of it. "],
["implementation-figures.html", " 12 Implementation figures 12.1 File statistics 12.2 Code statistics 12.3 Test and coverage", " 12 Implementation figures 12.1 File statistics R package version R files size Rd files size wyz.code.offensiveProgramming 1.1.12 34 46 30 34 wyz.code.testthat 1.1.7 7 8 3 6 wyz.code.metaTesting 1.1.2 25 44 15 24 wyz.code.rdoc 1.1.7 16 18 13 14 All sizes expressed in kilobytes. 12.2 Code statistics R package version exposed functions top level functions inner functions wyz.code.offensiveProgramming 1.1.12 30 64 70 wyz.code.testthat 1.1.7 4 11 16 wyz.code.metaTesting 1.1.2 16 44 96 wyz.code.rdoc 1.1.7 13 27 7 R package version strings comments code lines wyz.code.offensiveProgramming 1.1.12 444 24 989 wyz.code.testthat 1.1.7 4 72 9 wyz.code.metaTesting 1.1.2 230 46 1048 wyz.code.rdoc 1.1.7 219 19 329 12.3 Test and coverage R package version number of tests natural coverage wyz.code.offensiveProgramming 1.1.12 374 99.07% - 8 lines not covered wyz.code.testthat 1.1.7 20 99.35% - 1 line not covered wyz.code.metaTesting 1.1.2 402 99.68% - 2 lines not covered wyz.code.rdoc 1.1.7 76 97.71% - 6 lines not covered Natural coverage is the coverage without any coverage instrumentation. No file is off the coverage. No function nor code line is off also. In such a context, computed coverage really tells the percentage of lines covered by tests. "],
["conclusion.html", " 13 Conclusion 13.1 Benefits of offensive programming 13.2 Concerns of offensive programming 13.3 Your feedback is welcome", " 13 Conclusion 13.1 Benefits of offensive programming Neither exhaustive nor limitative list. Main benefits are Applicable to new and legacy code Code instrumentation at the required level, according to your needs. No obligation to comply completely or to instrument completely. Transient or persistent approach allow to deal with code you own and code you do not own. Evaluation modes eases incremental work. Offensive programming type_checking_enforcement mode is complimentary of standard R evaluation mode, not contesting with it. Usable at build time, at test time, and at run time wherever and whenever needed. Reusable test cases, immediately available to replay. No need to read manual pages to run a test case. No need to type or copy/paste code to replay a test Allow industrialization of test cases Allow fully automated generation of testthat test cases Allow fully automated generation of R documentation Most of all, offensive programming brings following value reduced code size, as many checks are no more necessary and shall no more be implemented higher developer’s productivity on R implementation, although earned time is varying greatly from function to function, depending of its complexity. I got more than 15% of time gain using offensive programming coding on several R package creations. Automated test case generation reduces greatly the burden of testthat content generation. Expect a productivity gain higher than 70% here. Documentation creation is now reduced in a great proportion, leaving just the review at your charge. Expect a productivity gain higher than 80% here. increased execution speed, due to reduced and simplified code. Again, many checks are no more necessary, and comparing, some traditional R code with offensive programming R code, will bring a clear value in favor of the second, as it tends not only to reduce the volume of code, but also to simplify your R code and to ease bug avoidance. The root cause of these two improvements is coming from type purity. 13.2 Concerns of offensive programming Again a neither exhaustive nor limitative list Non standard evaluation is always tricky and difficult to understand and put correctly in action, due to the two evaluation paradigms that are different from traditional R logic. Offensive programming is to be used wherever R standard evaluation scheme appears too limited or too lazy. The two extraneous evaluation paradigms might bring runtime performance issues, especially if you compare with standard R evaluation. Indeed, doing so is unfair, as it is not comparing apple to apple. Offensive programming adds two more kind of checks to be run to decide on result compliance, that are simply unknown from R standard evaluation scheme. Offensive programming requires some experience with it to fill comfortable in design, build, and run. Nevertheless, quite simple and intuitive, from a programming point of view. One piece of advice, be sure to have a clear idea of what you expect. In standard R, we are all used to get results without even asking ourselves any question about types, polymorphism, parameters and computed results. With offensive programming you must be able to answer clearly to such questions. 13.3 Your feedback is welcome Your feedback about package usefulness, package usage, and package extensions is welcome, as any improvement suggestion.Share them, this will really help me. I you wish to contribute to package development, just drop me an email. "],
["explicit-lege-feliciter.html", "Explicit - Lege feliciter", " Explicit - Lege feliciter "]
]
