[
["index.html", "Offensive Programming Book Welcome", " Offensive Programming Book Fabien GELINEAU neonira@gmail.com 2019-Q2 Welcome This is the website for “offensive programming”. This book will teach you how to put offensive programming in action with R. This website is and will remain free to use. It is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 3.0 License. The book is written in RMarkdown with bookdown. You may get access to the source for contributions. The book is for the moment just resulting of my efforts. Hope it will be enhanced and result from a collaborative effort very soon. "],
["preamble.html", "Preamble", " Preamble Package wyz.code.offensiveProgramming aims to provide a strict type checking enforcement in R. The R language is a weakly typed script language. As such, it simplifies greatly program writing and allows for great flexibility.That’s fine, and conceptually, there is no issue about that. Indeed, this leads more than desired to defensive programming practice. The absolute need to verify provided arguments, all along the function call chain, is very strong if you want to provide reliable and robust implementation. Consider following table about benefits of type control and type inference in lazy and strict type checking approaches. Goal Lazy type control (standard R) Strict type checking type control Weak type control implies coding of many contextual type controls Strong type checking brings some rigidity type inference requires knowledge and navigation from code to doc (forth and back) is required semantic naming allows more intuitive type inference Won’t it be nice to get the benefits of defensive programming and offensive programming, where ever and when ever needed? The main objective of package wyz.code.offensiveProgramming is to allow strict type checking in R to be as easy to use and to run as standard R "],
["programming-styles.html", " 1 Programming styles 1.1 Defensive programming style 1.2 Offensive programming style", " 1 Programming styles 1.1 Defensive programming style Defensive programming style consist of implementation of many controls at the entry of functions. This is required to ensure parameters meet some conditions required by the developer or the context. There are some benefits to this style. It is clearly incremental, and you can always add as many controls as desired, to meet the level of robustness and reliability you aim for. Indeed, this comes with some drawbacks that are repeated verifications at various depth levels, and worst the executed verifications are often the same code, leading to a waste of time during implementation, testing and execution. Second, an evolution of any function signature in the function call chain, may imply shallow or deep changes in the subsequent verifications, depending of the case. Defensive programming style also requires a good documentation, as there is no way to infer rationally and with a high level of confidence, what type has to be used for a given parameter of a function. Notice, that quality and consistency of type and value verification changes from one package to another. 1.2 Offensive programming style Offensive programming styles works differently. It is based on an implicit contract with bilateral responsibilities developer implements required verification about values, not about types unless absolutely required, end-user provides values with right or wrong types, when using developer delivered package type checks can be enforced at any time by end-user if needed. They are not hard coded by the developer in each function. In this way, the contract, is end-user is responsible of type concordance and developer is responsible of implementation from type concordance. Instrumentation is provided to let the end-user easily check the type concordance. "],
["application-in-r-language.html", " 2 Application in R language 2.1 A simple case 2.2 Defensive programming 2.3 Offensive programming 2.4 Back to definition", " 2 Application in R language 2.1 A simple case Consider following R class implementation which provides some basic mathematics operations. MathOperation &lt;- function() { self &lt;- environment() class(self) &lt;- append(&#39;Addition&#39;, class(self)) add &lt;- function(x, y) x + y multiply &lt;- function(x, y) x * y divide &lt;- function(x, y) x / y self } Let’s not argue about the design and relevancy of the approach. Instead, can you tell the scopes of each function, and identify/inventorize the implementations flaws ? 2.2 Defensive programming In standard R, the provided implementation might behave correctly, erroneously, or even generate errors, depending on the inputs you provide. Is it bad code ? Not at all according to me. The class name mentions clearly the intent that is to encapsulate some math operations. There are 3 operations. They can take any argument that can be accepted by operators ‘+’, ’*’ or ‘/’. So, providing, integers, doubles, and complex numbers should work. If you use an external package like gmp, it is also an acceptable input for any of the needed parameters. Any combination of this types will provide a correct result, using scalars or vectors. From my point of view, main issues are the followings issue number issue description issue severity 1 few seconds for creation, several quarters of an hour for testing, and hours for documentation UNACCEPTABLE 2 does it complies with maths sets? Not at all, this is software engineering implementation, not a math compliant one SEVERE 3 high sensitivity to input values did you consider that NaN, NA, Inf, -Inf, 0 could be valid input values here?. Indeed R is naturally great on this part LOW 4 natural polymorphism of returned types, that brings again software engineering whereas reliable math ops are needed. From a mathematical point of view, input belong to a predefined mathematical set, and output belongs also to a predefined mathematical set. Not the case with provided implementations HIGH 5 unreliable implementation as input might return numeric output, warning or errors HIGH 2.3 Offensive programming Consider same R class implementation with a little bit instrumentation. suppressMessages(require(data.table)) MathOperation &lt;- function() { self &lt;- environment() class(self) &lt;- append(&#39;Addition&#39;, class(self)) add &lt;- function(x_r, y_r) x_r + y_r multiply &lt;- function(x_r, y_r) x_r * y_r divide &lt;- function(x_r, y_r) x_r / y_r function_return_types &lt;- data.table( function_name = c(&#39;add&#39;, &#39;multiply&#39;, &#39;divide&#39;), return_value = c(&#39;x_r&#39;, &#39;x_r&#39;, &#39;x_d&#39;) ) self } 2.3.1 What is different? Compare to previously shown implementation, here are the two main differences arguments are renamed according to a pattern a variable named function_return_types has been added. It holds a data.table that defines expected function return types. That’s it. Function implementation is exactly the same. No change done elsewhere. Everything is there and should be sufficient to solve many of the faced issues. 2.3.2 Semantic argument naming Arguments have been renamed from x to x_r. What does that mean? Syntactically, it changes nothing for R. For us humans, it changes a lot of things, as this follows a pattern that allows to specify several intents in a short, concise, and reliable way. The pattern is simple to understand. Its parts can be up to three, and the second and third parts are optional. First part, is the variable name. Second part is the type of the variable. Third part is the length constraint specification. Part are separated by underscore. Refer to 5 for more details about syntax, and for illustrative examples. 2.4 Back to definition So now you may be able to translate the variable x_r by yourself. Just a vector of real values, unconstrained in length. Using this parameter name implies that the the developer is responsible for testing cases of various length and has to prevent weirdness propagation. For example following R code shows results that require decisions mo &lt;- MathOperation() print(mo$add(1.0 * 1:3, 1.0 * 1:7)) #&gt; Warning in x_r + y_r: la taille d&#39;un objet plus long n&#39;est pas multiple de #&gt; la taille d&#39;un objet plus court #&gt; [1] 2 4 6 5 7 9 8 This code provides both an output and a warning, because of R recycling on various length vectors. What decision should be taken ? Allow or deny this behavior ? It depends of your usage. If you are creating a real math library, I would recommend to duplicate the code and create two functions named addRCompliant and addMathCompliant. Later should enforce arguments length control in his body, while former should keep the body as is or instrument it with an encapsulating suppressWarning call. That way, you should easily meet your end-users expectations, either mathematicians or software engineers. Note that in the later case, added controls are not defensive programming but functional scope verification. "],
["putting-in-action-wyz-code-offensiveprogramming.html", " 3 Putting in action wyz.code.offensiveProgramming 3.1 Package overview", " 3 Putting in action wyz.code.offensiveProgramming The package provides R tools to ease offensive programming exploitation. 3.1 Package overview The package is organized around 4 axis that are elaboration, verification, exploitation and information. At any time you may get a list of the package functions by calling function packageFunctionsInformation that provides a truth table for each function in package wyz.code.offensiveProgramming. This is helpful when lost or just as a reminder. packageFunctionsInformation() #&gt; function elaboration verification #&gt; 1: defineEvaluationModes TRUE TRUE #&gt; 2: defineFunctionReturnTypesParameterName TRUE TRUE #&gt; 3: defineTestCaseDefinitionsParameterName TRUE TRUE #&gt; 4: EvaluationMode TRUE TRUE #&gt; 5: FunctionParameterTypeFactory TRUE TRUE #&gt; 6: FunctionParameterName TRUE TRUE #&gt; 7: TestCaseDefinition TRUE TRUE #&gt; 8: verifyClassName TRUE TRUE #&gt; 9: verifyFunctionName TRUE TRUE #&gt; 10: verifyObjectNames TRUE TRUE #&gt; 11: verifyFunctionReturnTypesDefinition TRUE TRUE #&gt; 12: verifyTestCaseDefinitions TRUE TRUE #&gt; 13: retrieveFunctionReturnTypes TRUE TRUE #&gt; 14: retrieveTestCaseDefinitions TRUE TRUE #&gt; 15: runFunction TRUE TRUE #&gt; 16: runTestCases TRUE TRUE #&gt; 17: packageFunctionsInformation TRUE TRUE #&gt; exploitation information kind user #&gt; 1: TRUE TRUE information developer #&gt; 2: TRUE TRUE information developer #&gt; 3: TRUE TRUE information developer #&gt; 4: TRUE TRUE elaboration developer #&gt; 5: TRUE TRUE elaboration developer #&gt; 6: FALSE FALSE elaboration developer #&gt; 7: FALSE FALSE elaboration developer #&gt; 8: TRUE TRUE verification developer #&gt; 9: TRUE TRUE verification developer #&gt; 10: TRUE TRUE verification developer #&gt; 11: TRUE TRUE verification integrator #&gt; 12: TRUE TRUE verification integrator #&gt; 13: TRUE TRUE exploitation integrator #&gt; 14: TRUE TRUE exploitation integrator #&gt; 15: TRUE TRUE exploitation end-user #&gt; 16: TRUE TRUE exploitation end-user #&gt; 17: TRUE TRUE information anyone "],
["the-type-factory.html", " 4 The type factory 4.1 Get recorded types inventory 4.2 Register your own type 4.3 Get access to verification functions 4.4 Some hints", " 4 The type factory The types that you wish to control are managed by a type factory, named FunctionParameterTypeFactory. Instantiating an object of this class allows you to discover what are the already available for reuse and recorded types register your own types so they can be checked dynamically wherever and whenever required understand the verification logic for each type 4.1 Get recorded types inventory Simply use retrieveFactory and getRecordedTypes functions. Here is an example. f &lt;- retrieveFactory() f$getRecordedTypes() #&gt; suffix type verify_function category #&gt; 1: a array &lt;function&gt; data structure #&gt; 2: b boolean &lt;function&gt; basic #&gt; 3: c complex &lt;function&gt; numeric #&gt; 4: ca call &lt;function&gt; language #&gt; 5: d double &lt;function&gt; numeric #&gt; 6: da date &lt;function&gt; date #&gt; 7: dc POSIXct &lt;function&gt; date #&gt; 8: dl POSIXlt &lt;function&gt; date #&gt; 9: e environment &lt;function&gt; basic #&gt; 10: ex expression &lt;function&gt; language #&gt; 11: er error &lt;function&gt; error management #&gt; 12: fa factor &lt;function&gt; basic #&gt; 13: f function &lt;function&gt; basic #&gt; 14: df data.frame &lt;function&gt; data structure #&gt; 15: dt data.table &lt;function&gt; data structure #&gt; 16: i integer &lt;function&gt; numeric #&gt; 17: l list &lt;function&gt; data structure #&gt; 18: lo logical &lt;function&gt; data structure #&gt; 19: m matrix &lt;function&gt; data structure #&gt; 20: n numeric &lt;function&gt; numeric #&gt; 21: na na &lt;function&gt; basic #&gt; 22: nm name &lt;function&gt; language #&gt; 23: o object &lt;function&gt; basic #&gt; 24: r raw &lt;function&gt; basic #&gt; 25: s string &lt;function&gt; basic #&gt; 26: t table &lt;function&gt; data structure #&gt; 27: w warning &lt;function&gt; error management #&gt; suffix type verify_function category 4.2 Register your own type Type registration is achieved by providing a type suffix, a type name and a verification function. Registration will be tagged automatically as user-defined. Here is a typical sequence to register your own type f$addSuffix(&#39;mc&#39;, &#39;MyClass&#39;, function(o_1_) is(o_1_, &#39;MyClass&#39;)) #&gt; [1] TRUE f$getRecordedTypes()[suffix == &#39;mc&#39;] #&gt; suffix type verify_function category #&gt; 1: mc MyClass &lt;function&gt; user defined Note that no implementation of the class is required. It is purely declarative registration. You told the type factory to record the type MyClass under the suffix mc, with the verification function you provided. Here verification function is quite simple. Notice, that it takes a single object as argument. 4.3 Get access to verification functions Implementation of verification function can range from quite simple to as complex as required. This allows you to manage functional scopes much more easily, whatever you work and organization context. For example, if you want to see at a glance the differences between a boolean and a logical, here is the sequence you could use f$getVerificationFunction(&#39;b&#39;) #&gt; function(o_1_) is.logical(o_1_) &amp;&amp; !is.na(o_1_) #&gt; &lt;bytecode: 0x000000001f1c2440&gt; #&gt; &lt;environment: 0x000000001f23ee08&gt; f$getVerificationFunction(&#39;logical&#39;) #&gt; function (x) .Primitive(&quot;is.logical&quot;) From the two definitions, you can deduce the differences between the two types. A boolean is a 2-value boolean, either TRUE or FALSE. A logical, is a R logical value, that is a 3-value boolean, so it may take value NA. Note that arguments to the function can be either a registered suffix or a registered type. 4.4 Some hints There is currently no way to remove one recorded type. This need is indeed very specific and arise only when there is a name collision and you wish to use an already taken name for your own purpose. Solution is quite simple, use another name. Provided types are the most commons, and the current suffixes have been chosen for ease of use and for intuitive usage. Whenever you need to register a new type, ask yourself ‘what is the suffix I wish to use for the new type?’. My advice is to use short suffixes, made of 2 or 3 letters. That’s clearly sufficient to distinguish your type from others. Know that there is not limitation to the length of the suffix you can use. Simply, comply with KISS, as you will have to type it several times. If you come from another programming language, you may consider to create aliased types by recording new entries. Let’s look at a concrete case. f$addSuffix(&#39;ui&#39;, &#39;unsigned integer&#39;, function(o_1_) f$getVerificationFunction(&#39;i&#39;)(o_1_) &amp;&amp; o_1_ &gt;= 0L) #&gt; [1] TRUE f$addSuffix(&#39;ul&#39;, &#39;unsigned long&#39; , f$getVerificationFunction(&#39;ui&#39;)) #&gt; [1] TRUE f$getRecordedTypes()[suffix %in% c(&#39;ui&#39;, &#39;ul&#39;)] #&gt; suffix type verify_function category #&gt; 1: ui unsigned integer &lt;function&gt; user defined #&gt; 2: ul unsigned long &lt;function&gt; user defined You just added two new entries in the type factory, and they share the same verification function. Now, ui and ul are aliases of the same verification function. Notice that this is true now, but can be changed whenever needed. In particular, you may change one or the other of the two functions as soon as you need to specialize the behavior. It depends largely on your case. The term alias shall not be understood, as an authorization to use one name for the other, but rather as an ability to define quickly new types to ease functional scope management. "],
["semantic-names.html", " 5 Semantic names 5.1 What is semantic naming? 5.2 Verifying a function parameter or return type declaration 5.3 Verifying a class name 5.4 Verifying a function name 5.5 Get naming balance from an R object", " 5 Semantic names Package wyz.code.offensiveProgramming offers great functionalities at the cost of a few conditions semantic naming has to be used for function parameters names semantic naming has to be used for function return type definition semantic naming has to be used for test case definitions 5.1 What is semantic naming? I call semantic naming, the fact that a named object used in the code should provide much more information than a dumb name. Semantic naming in package wyz.code.offensiveProgramming defines a few patterns to declare class, function, function parameters and function return type names. Table below shows the related patterns and exposes the underlying philosophy. name category philosophy pattern to comply with class java like, starts with upper-cased letter, camel-cased [A-Z][a-ZA-Z0-9]* function java like, starts with lower-cased letter, camel-cased [a-z][a-ZA-Z0-9]* function parameter or function return type R like, bearing information about type and length constraint See below. Function parameter or return type names must comply with one of the following patterns &lt;variableNameCamelCase&gt;&lt;_typeInformation&gt;&lt;_lengthConstraint&gt; &lt;variableNameCamelCase&gt;&lt;_lengthConstraint&gt;_ First pattern is to be used for monomorphic types. Second one for polymorphic types. Monomorphic types are types that are homogeneous. A string, a double, a MyObject are good example of such monomorphic types. Pattern allows to not only express concisely the type, but also to express some length constraints if needed. Polymorphic types are useful as soon as your input or output can take many types, according to your context. For example, a R function may return a double, or a warning, or an error. Polymorphic types always end with ’_’ in their names, to make them easy to identify. The type information part of the pattern has to match one of the recorded entries of the type factory. The length constraint part ot the pattern follows the PERL pattern ([1-9][0-9]*(l|m|n)?). Letters mean respectively less or equal, more or equal, 1 or n. The length constraint part is optional. Look at following table to get more intuitive traction on function parameter or function return type declarations. input name meaning x_s an unconstrained vector of strings - might contain no entries x_s_3 a vector of strings with 3 entries x_s_3l a vector of strings with 3 or less entries x_s_3m a vector of strings with 3 or more entries x_s_3n a vector of strings with 3 entries or 1 entry flag_b_1 a vector of booleans with 1 entry - a.k.a a boolean scalar z_ an unconstrained polymorphic type vector named z - Nothing more is known about its content z_2_ a polymorphic type vector named z of length 2 - Nothing more is known about its content As you can see, rather easy. An advice, when programming try to use meaningful variable names for first part of the pattern. It will ease your job. 5.2 Verifying a function parameter or return type declaration Use simply dedicated function named getTypeDescription from the type factory. sapply(c(&#39;x_s_3n&#39;, &#39;flag_b_1&#39;, &#39;z_2_&#39;), function(e) f$getTypeDescription(FunctionParameterName(e))) #&gt; x_s_3n #&gt; &quot;A constrained vector of string values. Vector length must be 1 or 3.&quot; #&gt; flag_b_1 #&gt; &quot;A constrained vector of boolean values. Vector length must be 1.&quot; #&gt; z_2_ #&gt; &quot;A constrained vector of variable type objects. Vector length must be 2.&quot; 5.3 Verifying a class name Simply use package eponymous function. verifyClassName(c(&#39;alphaBeta&#39;, &#39;AlphaBeta&#39;, &#39;.alphaBeta&#39;)) #&gt; alphaBeta AlphaBeta .alphaBeta #&gt; FALSE TRUE FALSE verifyClassName(c(&#39;alphaBeta&#39;, &#39;AlphaBeta&#39;, &#39;.alphaBeta&#39;), strict = FALSE) #&gt; alphaBeta AlphaBeta .alphaBeta #&gt; TRUE TRUE TRUE 5.4 Verifying a function name Simply use package eponymous function. verifyFunctionName(c(&#39;alphaBetaGamma&#39;, &#39;AlphaBetaGamma&#39;, &#39;.alphaBetaGamma&#39;)) #&gt; alphaBetaGamma AlphaBetaGamma .alphaBetaGamma #&gt; TRUE FALSE FALSE verifyFunctionName(c(&#39;alphaBetaGamma&#39;, &#39;AlphabetaGamma&#39;, &#39;.alphaBetaGamma&#39;), strict = FALSE) #&gt; alphaBetaGamma AlphabetaGamma .alphaBetaGamma #&gt; TRUE TRUE TRUE 5.5 Get naming balance from an R object Use package function verifyObjectNames to get the results of a full compliance analysis of names for the provided object. source(system.file(&#39;code-samples/no-instrumentation/Addition.R&#39;, package = &#39;wyz.code.offensiveProgramming&#39;)) verifyObjectNames(Addition()) #&gt; $class_name_compliance #&gt; Addition #&gt; TRUE #&gt; #&gt; $function_name_compliance #&gt; addDouble addInteger addNumeric divideByZero #&gt; TRUE TRUE TRUE TRUE #&gt; generateError generateWarning #&gt; TRUE TRUE #&gt; #&gt; $parameter_name_compliance #&gt; function_name parameter_name name_compliance_check #&gt; 1: addDouble x_d TRUE #&gt; 2: addDouble y_d TRUE #&gt; 3: addInteger x_i TRUE #&gt; 4: addInteger y_i TRUE #&gt; 5: addNumeric x FALSE #&gt; 6: addNumeric y_n TRUE #&gt; 7: divideByZero x_n TRUE #&gt; 8: generateError &lt;NA&gt; TRUE #&gt; 9: generateWarning x_ TRUE #&gt; semantic_naming_check #&gt; 1: TRUE #&gt; 2: TRUE #&gt; 3: TRUE #&gt; 4: TRUE #&gt; 5: FALSE #&gt; 6: TRUE #&gt; 7: TRUE #&gt; 8: TRUE #&gt; 9: TRUE #&gt; #&gt; $classname #&gt; [1] &quot;Addition&quot; #&gt; #&gt; $owns_function_return_type_information #&gt; [1] FALSE #&gt; #&gt; $owns_test_case_definitions #&gt; [1] FALSE #&gt; #&gt; $supports_strict_compliance #&gt; [1] FALSE #&gt; #&gt; $supports_lazy_compliance #&gt; [1] FALSE #&gt; #&gt; $can_be_typed_checked #&gt; [1] FALSE #&gt; #&gt; $is_function_fully_instrumented #&gt; [1] FALSE #&gt; #&gt; $missing_functions #&gt; [1] NA #&gt; #&gt; $is_test_case_fully_instrumented #&gt; [1] FALSE #&gt; #&gt; $missing_test_cases #&gt; [1] NA source(system.file(&#39;code-samples/full-instrumentation/AdditionTCFIG1.R&#39;, package = &#39;wyz.code.offensiveProgramming&#39;)) verifyObjectNames(AdditionTCFIG1()) #&gt; $class_name_compliance #&gt; AdditionTCFIG1 #&gt; TRUE #&gt; #&gt; $function_name_compliance #&gt; addDouble addInteger addMultiDouble addMultiInteger #&gt; TRUE TRUE TRUE TRUE #&gt; addNumeric divideByZero generateError generateWarning #&gt; TRUE TRUE TRUE TRUE #&gt; #&gt; $parameter_name_compliance #&gt; function_name parameter_name name_compliance_check #&gt; 1: addDouble x_d TRUE #&gt; 2: addDouble y_d TRUE #&gt; 3: addInteger x_i TRUE #&gt; 4: addInteger y_i TRUE #&gt; 5: addMultiDouble ... TRUE #&gt; 6: addMultiInteger x_i TRUE #&gt; 7: addMultiInteger ... TRUE #&gt; 8: addNumeric x_n TRUE #&gt; 9: addNumeric y_n TRUE #&gt; 10: divideByZero x_n TRUE #&gt; 11: generateError &lt;NA&gt; TRUE #&gt; 12: generateWarning x_ TRUE #&gt; semantic_naming_check #&gt; 1: TRUE #&gt; 2: TRUE #&gt; 3: TRUE #&gt; 4: TRUE #&gt; 5: TRUE #&gt; 6: TRUE #&gt; 7: TRUE #&gt; 8: TRUE #&gt; 9: TRUE #&gt; 10: TRUE #&gt; 11: TRUE #&gt; 12: TRUE #&gt; #&gt; $classname #&gt; [1] &quot;AdditionTCFIG1&quot; #&gt; #&gt; $owns_function_return_type_information #&gt; [1] TRUE #&gt; #&gt; $owns_test_case_definitions #&gt; [1] TRUE #&gt; #&gt; $supports_strict_compliance #&gt; [1] TRUE #&gt; #&gt; $supports_lazy_compliance #&gt; [1] TRUE #&gt; #&gt; $can_be_typed_checked #&gt; [1] TRUE #&gt; #&gt; $is_function_fully_instrumented #&gt; [1] TRUE #&gt; #&gt; $missing_functions #&gt; [1] &quot;none&quot; #&gt; #&gt; $is_test_case_fully_instrumented #&gt; [1] FALSE #&gt; #&gt; $missing_test_cases #&gt; [1] &quot;addNumeric&quot; "],
["evaluation-modes.html", " 6 Evaluation modes 6.1 Understanding evaluation modes 6.2 Instantiating evaluation mode", " 6 Evaluation modes Package wyz.code.offensiveProgramming comes with several evaluation modes. You may retrieve them by using function defineEvaluationModes that returns the 3 following modes standard_R_evaluation enhanced_R_evaluation type_checking_enforcement 6.1 Understanding evaluation modes The first mode, standard_R_evaluation, is to ease comparisons with standard R evaluation. It does not make any sense to use only this mode when using wyz.code.offensiveProgramming. The second mode, enhanced_R_evaluation, goes further than standard R evaluation, as it implies a function return type verification. The third mode, type_checking_enforcement, goes still further than the second mode, as it implies a function parameter types verification. Roughly speaking, second mode let’s you verify function return types in accordance with recorded information, and the third mode, mimics a compiler output for R but it still interpreted language. 6.2 Instantiating evaluation mode To handle evaluation mode, use function EvaluationMode. A typical way to do so is em &lt;- EvaluationMode(defineEvaluationModes()[3]) "],
["running-functions.html", " 7 Running functions 7.1 Prerequisites 7.2 Function return types definition verification 7.3 Transient invocations 7.4 Persistent invocations", " 7 Running functions Our goal is to run a R instrumented function, under a given evaluation mode. To do so, some prerequisites have to be met, prior to use some wyz.code.offensiveProgramming utilities to proceed to the function execution with context capture and human-readable feedback generation. 7.1 Prerequisites To run a R function is has to be instrumented. Two requirements have to be met the function must comply with semantic parameter naming the function return type must be specified 7.2 Function return types definition verification To verify function return types definition you may use the low level function verifyFunctionReturnTypesDefinition or the higher level one named retrieveFunctionReturnTypes. Indeed, this approach requires persistent instrumentation of the code. retrieveFunctionReturnTypes(AdditionTCFIG1()) #&gt; function_name return_value #&gt; 1: addNumeric x_n #&gt; 2: addDouble x_d #&gt; 3: addInteger x_i #&gt; 4: addMultiDouble x_d #&gt; 5: divideByZero x_d #&gt; 6: addMultiInteger x_i #&gt; 7: generateWarning x_w #&gt; 8: generateError x_er 7.3 Transient invocations Transient means instrumentation is done dynamically and not persisted anywhere. Here is a typical case. That’s a convenient way to discover and to play with package wyz.code.offensiveProgramming. 7.3.1 Nominal case h &lt;- function(x_s) x_s runTransientFunction(h, list(&#39;neonira&#39;), EvaluationMode(defineEvaluationModes()[3]), &#39;x_s&#39;) #&gt; $status #&gt; [1] TRUE #&gt; #&gt; $value #&gt; [1] &quot;neonira&quot; #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_s neonira TRUE good type in values #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_s neonira TRUE good type in values Semantically, function h takes a vector of strings as argument and returns a vector of strings. As provided parameter ‘neonira’ is a vector of type character, parameter_type_checks succeed. As returned value is a vector of type character, function_return_type_check also succeeds. 7.3.1.1 Wrong parameter type Let’s change the provided argument from ‘neonira’ to pi value. h &lt;- function(x_s) x_s runTransientFunction(h, list(pi), EvaluationMode(defineEvaluationModes()[3]), &#39;x_s&#39;) #&gt; $status #&gt; [1] FALSE #&gt; #&gt; $value #&gt; [1] 3.141593 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_s 3.141593 FALSE wrong type in values #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_s 3.141593 FALSE wrong type in values We now face a case where function specification is unchanged but provided argument is not complying to specification. Impact is parameter_type_checks failure and function_return_type_check failure. 7.3.1.2 Change expected return type Let’s change the expected function return type, to be double x_d. h &lt;- function(x_s) x_s runTransientFunction(h, list(pi), EvaluationMode(defineEvaluationModes()[3]), &#39;x_d&#39;) #&gt; $status #&gt; [1] FALSE #&gt; #&gt; $value #&gt; [1] 3.141593 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_s 3.141593 FALSE wrong type in values #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_d 3.141593 TRUE good type in values We now face a case where function specification is unchanged but expected return type is expected to be a double. Provided argument is not complying to specification. Impact is parameter_type_checks failure. 7.3.2 Prerequisite mismatch What if function is not fulfilling prerequisites g &lt;- function(x) x # No semantic name compliance runTransientFunction(g, list(pi), EvaluationMode(defineEvaluationModes()[3]), &#39;x_d&#39;) #&gt; $status #&gt; [1] FALSE #&gt; #&gt; $value #&gt; [1] 3.141593 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x 3.141593 FALSE unknown suffix, [NA] #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_d 3.141593 TRUE good type in values Impact is parameter_type_checks failure. 7.4 Persistent invocations Transient invocations are convenient but limited. Especially, when you create classes, they do not appear to be as friendly and useful as necessary. When dealing with your own class code, you may opt for an easier and more industrial approach that is class instrumentation. Prerequisite remains the same, but you may fulfill them much more easily by defining a variable named function_return_type in your class. Let’s see an example. 7.4.1 Nominal persistent case source(system.file(&#39;code-samples/fun-defs/good/partial/AdditionFIPartial.R&#39;, package = &#39;wyz.code.offensiveProgramming&#39;)) runFunction(AdditionFIPartial(), &#39;addInteger&#39;, list(1:3, 6:8), EvaluationMode(defineEvaluationModes()[3])) #&gt; $status #&gt; [1] TRUE #&gt; #&gt; $value #&gt; [1] 7 9 11 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 1,2,3 TRUE good type in values #&gt; 2: y_i 6,7,8 TRUE good type in values #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 7, 9,11 TRUE good type in values We now face a case where function specification is expecting to sum integers. Provided arguments are complying to specification. Impact is parameter_type_checks success and function_return_type_check success. 7.4.2 Subtile change Just change the function name. Now expectations brought by the function definition are not the same. This leads to a completely different result. runFunction(AdditionFIPartial(), &#39;addDouble&#39;, list(1:3, 6:8), EvaluationMode(defineEvaluationModes()[3])) #&gt; $status #&gt; [1] FALSE #&gt; #&gt; $value #&gt; [1] 7 9 11 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_d 1,2,3 FALSE wrong type in values #&gt; 2: y_d 6,7,8 FALSE wrong type in values #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_d 7, 9,11 FALSE wrong type in values 7.4.3 Call case with named and positional parameters runFunction(AdditionFIPartial(), &#39;addInteger&#39;, list(y_i = 1:3, 6:8), EvaluationMode(defineEvaluationModes()[3])) #&gt; $status #&gt; [1] TRUE #&gt; #&gt; $value #&gt; [1] 7 9 11 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: y_i 1,2,3 TRUE good type in values #&gt; 2: x_i 6,7,8 TRUE good type in values #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 7, 9,11 TRUE good type in values Look at parameter_type_checks to ensure arguments are well associated. 7.4.4 Call case with ellipsis runFunction(AdditionFIPartial(), &#39;addMultiDouble&#39;, list(1:3, 1:7), EvaluationMode(defineEvaluationModes()[3])) #&gt; $status #&gt; [1] TRUE #&gt; #&gt; $value #&gt; [1] 34 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: ... 1,2,3 TRUE ellispsis match all #&gt; 2: ... 1,2,3,4,5,6,... TRUE ellispsis match all #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_d 34 TRUE good type in values 7.4.5 Second call case with ellipsis runFunction(AdditionFIPartial(), &#39;addMultiInteger&#39;, list(1:3, 1:7, 0, floor(pi)), EvaluationMode(defineEvaluationModes()[3])) #&gt; $status #&gt; [1] FALSE #&gt; #&gt; $value #&gt; [1] 32 33 34 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 1,2,3 TRUE good type in values #&gt; 2: ... 1,2,3,4,5,6,... TRUE ellispsis match all #&gt; 3: ... 0 TRUE ellispsis match all #&gt; 4: ... 3 TRUE ellispsis match all #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 32,33,34 FALSE wrong type in values Two issues here. Value 0 is double, not integer and floor function returns also a double. To get a correct results here is how to transform the call runFunction(AdditionFIPartial(), &#39;addMultiInteger&#39;, list(1:3, 1:7, 0L, as.integer(floor(pi))), EvaluationMode(defineEvaluationModes()[3])) #&gt; $status #&gt; [1] TRUE #&gt; #&gt; $value #&gt; [1] 32 33 34 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 1,2,3 TRUE good type in values #&gt; 2: ... 1,2,3,4,5,6,... TRUE ellispsis match all #&gt; 3: ... 0 TRUE ellispsis match all #&gt; 4: ... 3 TRUE ellispsis match all #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 32,33,34 TRUE good type in values "],
["running-test-cases.html", " 8 Running test cases 8.1 Embedding test cases in class definition 8.2 Test case definitions verification 8.3 Run a test case", " 8 Running test cases Using package wyz.code.offensiveProgramming, you have the opportunity to define test cases and to embed them in your class definition, to ease retrieval and reuse. 8.1 Embedding test cases in class definition This is accomplished easily. You just have to declare a variable named testCaseDefinitions, and provide its content, that is a data.table. Content could be partial or complete depending of your goals. Spectrum of provided tests cases is as you desire it to be, as shallow or deep as needed. The data.table must hold following columns and content function_name, a vector of strings, each being the name of the function to test, standard_evaluation, a vector of strings, where values are taken from set {‘correct’, ‘erroneous’, ‘failure’} type_checking_enforcement, , a vector of strings, where values are taken from set {‘correct’, ‘erroneous’, ‘failure’} test case definitions, that is a list of TestCaseDefinition objects. Correct implies right type and right result. Erroneous implies right type and wrong result. Failure implies wrong type. To get more details about syntax, please refer to manual page of Definitions. 8.1.1 A simple case source(system.file(&#39;code-samples/full-instrumentation/AdditionTCFIP.R&#39;, package = &#39;wyz.code.offensiveProgramming&#39;)) AdditionTCFIP #&gt; function () #&gt; { #&gt; self &lt;- environment() #&gt; class(self) &lt;- append(&quot;AdditionTCFIP&quot;, class(self)) #&gt; addNumeric &lt;- function(x_n, y_n) x_n + y_n #&gt; addDouble &lt;- function(x_d, y_d = 0, ...) x_d + y_d + ... #&gt; addInteger &lt;- function(x_i, y_i) x_i + y_i #&gt; divideByZero &lt;- function(x_n) x_n/0 #&gt; generateWarning &lt;- function(x_ = 8L) 1:3 + 1:7 + x_ #&gt; generateError &lt;- function() stop(&quot;generated error&quot;) #&gt; function_return_types &lt;- data.table(function_name = c(&quot;addNumeric&quot;, #&gt; &quot;addDouble&quot;, &quot;addInteger&quot;, &quot;divideByZero&quot;, &quot;generateWarning&quot;, #&gt; &quot;generateError&quot;), return_value = c(&quot;x_n&quot;, &quot;x_d&quot;, &quot;x_i&quot;, #&gt; &quot;x_d&quot;, &quot;x_w&quot;, &quot;x_er&quot;)) #&gt; test_case_definitions &lt;- data.table(function_name = c(&quot;addDouble&quot;, #&gt; &quot;addInteger&quot;, &quot;divideByZero&quot;, &quot;divideByZero&quot;, &quot;generateWarning&quot;, #&gt; &quot;generateError&quot;), standard_evaluation = c(&quot;correct&quot;, #&gt; &quot;correct&quot;, &quot;correct&quot;, &quot;correct&quot;, &quot;failure&quot;), type_checking_enforcement = c(&quot;correct&quot;, #&gt; &quot;erroneous&quot;, &quot;correct&quot;, &quot;correct&quot;, &quot;correct&quot;), test_case = list(TestCaseDefinition(list(as.double(34L), #&gt; 44.5), 78.5, &quot;sum 2 doubles&quot;), TestCaseDefinition(list(34L, #&gt; 44.5), 78L, &quot;sum 1 integer and 1 double&quot;), TestCaseDefinition(list(1), #&gt; Inf, &quot;1 / 0&quot;), TestCaseDefinition(list(0), NaN, &quot;0 / 0&quot;), #&gt; TestCaseDefinition(list(0), 1:3 + 1:7, &quot;generate warning&quot;), #&gt; TestCaseDefinition(list(), NA, &quot;generate error&quot;))) #&gt; self #&gt; } Just five test cases to test 5 function with various parameters. 8.1.2 A more complex case AdditionTCFIG1 #&gt; function () #&gt; { #&gt; self &lt;- environment() #&gt; class(self) &lt;- append(&quot;AdditionTCFIG1&quot;, class(self)) #&gt; addNumeric &lt;- function(x_n, y_n) x_n + y_n #&gt; addDouble &lt;- function(x_d, y_d) x_d + y_d #&gt; addInteger &lt;- function(x_i, y_i) x_i + y_i #&gt; addMultiDouble &lt;- function(...) as.double(sum(..., na.rm = TRUE)) #&gt; addMultiInteger &lt;- function(x_i, ...) x_i + sum(..., na.rm = TRUE) #&gt; divideByZero &lt;- function(x_n) x_n/0 #&gt; generateWarning &lt;- function(x_) 1:3 + 1:7 #&gt; generateError &lt;- function() stop(&quot;generated error&quot;) #&gt; function_return_types &lt;- data.table(function_name = c(&quot;addNumeric&quot;, #&gt; &quot;addDouble&quot;, &quot;addInteger&quot;, &quot;addMultiDouble&quot;, &quot;divideByZero&quot;, #&gt; &quot;addMultiInteger&quot;, &quot;generateWarning&quot;, &quot;generateError&quot;), #&gt; return_value = c(&quot;x_n&quot;, &quot;x_d&quot;, &quot;x_i&quot;, &quot;x_d&quot;, &quot;x_d&quot;, &quot;x_i&quot;, #&gt; &quot;x_w&quot;, &quot;x_er&quot;)) #&gt; test_case_definitions &lt;- data.table(function_name = c(rep(&quot;addDouble&quot;, #&gt; 9), rep(&quot;addInteger&quot;, 9), rep(&quot;divideByZero&quot;, 3), &quot;generateWarning&quot;, #&gt; &quot;generateError&quot;, rep(&quot;addMultiDouble&quot;, 3), rep(&quot;addMultiInteger&quot;, #&gt; 3)), standard_evaluation = c(rep(&quot;correct&quot;, 5), &quot;erroneous&quot;, #&gt; rep(&quot;correct&quot;, 7), &quot;erroneous&quot;, rep(&quot;correct&quot;, 8), &quot;failure&quot;, #&gt; rep(&quot;correct&quot;, 6)), type_checking_enforcement = c(rep(&quot;correct&quot;, #&gt; 5), &quot;erroneous&quot;, rep(&quot;failure&quot;, 3), rep(&quot;correct&quot;, 4), #&gt; rep(&quot;failure&quot;, 5), rep(&quot;correct&quot;, 3), &quot;correct&quot;, &quot;failure&quot;, #&gt; &quot;correct&quot;, &quot;correct&quot;, &quot;correct&quot;, &quot;correct&quot;, &quot;failure&quot;, #&gt; &quot;correct&quot;), test_case = list(TestCaseDefinition(list(as.double(34L), #&gt; 44.5), 78.5, &quot;sum 2 doubles&quot;), TestCaseDefinition(list(34, #&gt; NA_real_), NA_real_, &quot;sum 1 double and 1 NA_real_&quot;), #&gt; TestCaseDefinition(list(NA_real_, NA_real_), NA_real_, #&gt; &quot;sum 2 NA_real_&quot;), TestCaseDefinition(list(NaN, NaN), #&gt; NaN, &quot;sum 2 NAN&quot;), TestCaseDefinition(list(Inf, Inf), #&gt; Inf, &quot;sum 2 Inf&quot;), TestCaseDefinition(list(as.integer(34.7), #&gt; as.integer(44.9)), 80, &quot;sum 2 as.integers confused with sum of rounded value as expectation&quot;), #&gt; TestCaseDefinition(list(34L, 44.5), 78.5, &quot;sum of 1 integer and 1 double&quot;), #&gt; TestCaseDefinition(list(34, NA_integer_), NA_real_, &quot;sum of 1 integer and 1 double&quot;), #&gt; TestCaseDefinition(list(NA, NA), NA, &quot;sum 2 NA&quot;), TestCaseDefinition(list(34L, #&gt; as.integer(44.5)), 78L, &quot;sum 2 integers&quot;), TestCaseDefinition(list(34L, #&gt; NA_integer_), NA_integer_, &quot;sum 1 integer and 1 NA_integer&quot;), #&gt; TestCaseDefinition(list(NA_integer_, NA_integer_), NA_integer_, #&gt; &quot;sum 2 NA_integer&quot;), TestCaseDefinition(list(as.integer(&quot;45.654&quot;), #&gt; 44L), 89L, &quot;sum a converted string with one integer&quot;), #&gt; TestCaseDefinition(list(34L, 44.5), 78L, &quot;sum 1 integer and 1 double&quot;), #&gt; TestCaseDefinition(list(34L, Inf), Inf, &quot;sum 1 integer and 1 Inf&quot;), #&gt; TestCaseDefinition(list(34L, NaN), NaN, &quot;sum 1 integer and 1 NAN&quot;), #&gt; TestCaseDefinition(list(34L, NA), NA, &quot;sum 1 integer and 1 NA&quot;), #&gt; TestCaseDefinition(list(c(34L, 35L), 44L), c(78L, 79L), #&gt; &quot;sum a vector of 2 integers with 1 integer&quot;), TestCaseDefinition(list(1), #&gt; Inf, &quot;1 / 0&quot;), TestCaseDefinition(list(-1), -Inf, #&gt; &quot;-1 / 0&quot;), TestCaseDefinition(list(0), NaN, &quot;0 / 0&quot;), #&gt; TestCaseDefinition(list(0), 1:3 + 1:7, &quot;generate warning&quot;), #&gt; TestCaseDefinition(list(), NA, &quot;generate error&quot;), TestCaseDefinition(list(34L, #&gt; 44.5), 78.5, &quot;sum of 1 integer and 1 double&quot;), TestCaseDefinition(list(34, #&gt; 35L, 36L, NA_integer_), 105, &quot;sum of 1 double, 2 integers and 1 NA_integer_&quot;), #&gt; TestCaseDefinition(list(), 0, &quot;sum of nothing&quot;), TestCaseDefinition(list(34L, #&gt; 44L, 1L, 1L), 80L, &quot;sum of 4 integers&quot;), TestCaseDefinition(list(34L, #&gt; 35, 36, NA_integer_), 105, &quot;sum of 1 integer, 2 doubles and 1 NA_integer_&quot;), #&gt; TestCaseDefinition(list(34L), 34L, &quot;sum of one integer and nothing&quot;))) #&gt; label &lt;- &quot;erroneous class instrumentation: test cases uses function divideByZero that is not instrumented for type checking enforcement&quot; #&gt; self #&gt; } #&gt; &lt;bytecode: 0x000000001d792918&gt; Much more complete instrumentation with 29 test cases, various expected outputs, varying from evaluation model to consider. 8.2 Test case definitions verification To verify test cases definitions you may use the low level function verifyTestCaseDefinitions or the higher level one named retrieveTestCaseDefinitions. retrieveTestCaseDefinitions(AdditionTCFIG1()) #&gt; function_name standard_evaluation type_checking_enforcement #&gt; 1: addDouble correct correct #&gt; 2: addDouble correct correct #&gt; 3: addDouble correct correct #&gt; 4: addDouble correct correct #&gt; 5: addDouble correct correct #&gt; 6: addDouble erroneous erroneous #&gt; 7: addDouble correct failure #&gt; 8: addDouble correct failure #&gt; 9: addDouble correct failure #&gt; 10: addInteger correct correct #&gt; 11: addInteger correct correct #&gt; 12: addInteger correct correct #&gt; 13: addInteger correct correct #&gt; 14: addInteger erroneous failure #&gt; 15: addInteger correct failure #&gt; 16: addInteger correct failure #&gt; 17: addInteger correct failure #&gt; 18: addInteger correct failure #&gt; 19: divideByZero correct correct #&gt; 20: divideByZero correct correct #&gt; 21: divideByZero correct correct #&gt; 22: generateWarning correct correct #&gt; 23: generateError failure failure #&gt; 24: addMultiDouble correct correct #&gt; 25: addMultiDouble correct correct #&gt; 26: addMultiDouble correct correct #&gt; 27: addMultiInteger correct correct #&gt; 28: addMultiInteger correct failure #&gt; 29: addMultiInteger correct correct #&gt; function_name standard_evaluation type_checking_enforcement #&gt; test_case #&gt; 1: &lt;TestCaseDefinition&gt; #&gt; 2: &lt;TestCaseDefinition&gt; #&gt; 3: &lt;TestCaseDefinition&gt; #&gt; 4: &lt;TestCaseDefinition&gt; #&gt; 5: &lt;TestCaseDefinition&gt; #&gt; 6: &lt;TestCaseDefinition&gt; #&gt; 7: &lt;TestCaseDefinition&gt; #&gt; 8: &lt;TestCaseDefinition&gt; #&gt; 9: &lt;TestCaseDefinition&gt; #&gt; 10: &lt;TestCaseDefinition&gt; #&gt; 11: &lt;TestCaseDefinition&gt; #&gt; 12: &lt;TestCaseDefinition&gt; #&gt; 13: &lt;TestCaseDefinition&gt; #&gt; 14: &lt;TestCaseDefinition&gt; #&gt; 15: &lt;TestCaseDefinition&gt; #&gt; 16: &lt;TestCaseDefinition&gt; #&gt; 17: &lt;TestCaseDefinition&gt; #&gt; 18: &lt;TestCaseDefinition&gt; #&gt; 19: &lt;TestCaseDefinition&gt; #&gt; 20: &lt;TestCaseDefinition&gt; #&gt; 21: &lt;TestCaseDefinition&gt; #&gt; 22: &lt;TestCaseDefinition&gt; #&gt; 23: &lt;TestCaseDefinition&gt; #&gt; 24: &lt;TestCaseDefinition&gt; #&gt; 25: &lt;TestCaseDefinition&gt; #&gt; 26: &lt;TestCaseDefinition&gt; #&gt; 27: &lt;TestCaseDefinition&gt; #&gt; 28: &lt;TestCaseDefinition&gt; #&gt; 29: &lt;TestCaseDefinition&gt; #&gt; test_case 8.3 Run a test case To run a test case, you may use the package function runTestCase. runTestCase(AdditionTCFIG1(), 4, EvaluationMode(defineEvaluationModes()[3])) #&gt; $raw #&gt; $raw$addDouble #&gt; $raw$addDouble$status #&gt; [1] TRUE #&gt; #&gt; $raw$addDouble$value #&gt; [1] 78.5 #&gt; #&gt; $raw$addDouble$mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $raw$addDouble$parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_d 34 TRUE good type in values #&gt; 2: y_d 44.5 TRUE good type in values #&gt; #&gt; $raw$addDouble$function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_d 78.5 TRUE good type in values #&gt; #&gt; $raw$addDouble$index #&gt; [1] 4 #&gt; #&gt; #&gt; #&gt; $synthesis #&gt; status mode index #&gt; 1: TRUE type_checking_enforcement 4 This runs the test number 4. Result has two parts. A raw part, that holds the intermediate computation results, and a synthesis part that is a data.table provided to ease result interpretation. Here, as result is true, You may provide a vector instead of a single test number if you want to run several use test cases in one call. runTestCase(AdditionTCFIG1(), 12:17, EvaluationMode(defineEvaluationModes()[3])) #&gt; $raw #&gt; $raw$addInteger #&gt; $raw$addInteger$status #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$value #&gt; [1] 78.5 #&gt; #&gt; $raw$addInteger$mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $raw$addInteger$parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_d 34 TRUE good type in values #&gt; 2: y_d 44.5 TRUE good type in values #&gt; #&gt; $raw$addInteger$function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_d 78.5 TRUE good type in values #&gt; #&gt; $raw$addInteger$index #&gt; [1] 12 #&gt; #&gt; #&gt; $raw$addInteger #&gt; $raw$addInteger$status #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$value #&gt; [1] NA #&gt; #&gt; $raw$addInteger$mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $raw$addInteger$parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_d 34 TRUE good type in values #&gt; 2: y_d NA TRUE good type in values #&gt; #&gt; $raw$addInteger$function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_d NA TRUE good type in values #&gt; #&gt; $raw$addInteger$index #&gt; [1] 13 #&gt; #&gt; #&gt; $raw$addInteger #&gt; $raw$addInteger$status #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$value #&gt; [1] NA #&gt; #&gt; $raw$addInteger$mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $raw$addInteger$parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_d NA TRUE good type in values #&gt; 2: y_d NA TRUE good type in values #&gt; #&gt; $raw$addInteger$function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_d NA TRUE good type in values #&gt; #&gt; $raw$addInteger$index #&gt; [1] 14 #&gt; #&gt; #&gt; $raw$addInteger #&gt; $raw$addInteger$status #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$value #&gt; [1] NaN #&gt; #&gt; $raw$addInteger$mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $raw$addInteger$parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_d NaN TRUE good type in values #&gt; 2: y_d NaN TRUE good type in values #&gt; #&gt; $raw$addInteger$function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_d NaN TRUE good type in values #&gt; #&gt; $raw$addInteger$index #&gt; [1] 15 #&gt; #&gt; #&gt; $raw$addInteger #&gt; $raw$addInteger$status #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$value #&gt; [1] Inf #&gt; #&gt; $raw$addInteger$mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $raw$addInteger$parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_d Inf TRUE good type in values #&gt; 2: y_d Inf TRUE good type in values #&gt; #&gt; $raw$addInteger$function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_d Inf TRUE good type in values #&gt; #&gt; $raw$addInteger$index #&gt; [1] 16 #&gt; #&gt; #&gt; $raw$addInteger #&gt; $raw$addInteger$status #&gt; [1] FALSE #&gt; #&gt; $raw$addInteger$value #&gt; [1] 78 #&gt; #&gt; $raw$addInteger$mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $raw$addInteger$parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_d 34 FALSE wrong type in values #&gt; 2: y_d 44 FALSE wrong type in values #&gt; #&gt; $raw$addInteger$function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_d 78 FALSE wrong type in values #&gt; #&gt; $raw$addInteger$index #&gt; [1] 17 #&gt; #&gt; #&gt; #&gt; $synthesis #&gt; status mode index #&gt; 1: TRUE type_checking_enforcement 12 #&gt; 2: TRUE type_checking_enforcement 13 #&gt; 3: TRUE type_checking_enforcement 14 #&gt; 4: TRUE type_checking_enforcement 15 #&gt; 5: TRUE type_checking_enforcement 16 #&gt; 6: FALSE type_checking_enforcement 17 Looking at synthesis, you will discover that test 17 fails under chosen evaluation mode, and therefore should require a fix. Here looking at raw results for test number 17, brings solution, that is about input parameter compliance. Provided values are double, whereas integers were expected. "],
["conclusion.html", " 9 Conclusion 9.1 Benefits of offensive programming 9.2 Concerns of offensive programming 9.3 Two extensions 9.4 Your feedback is welcome", " 9 Conclusion 9.1 Benefits of offensive programming Neither exhaustive nor limitative list. Main benefits are Applicable to new and legacy code Code instrumentation at the required level, according to your needs. No obligation to comply completely or to instrument completely. Transient or persistent approach allow to deal with code you own and code you do not own. Evaluation modes eases incremental work. Offensive programming type_checking_enforcement mode is complimentary of standard R evaluation mode, not contesting with it. Usable a build time, at test time, and at run time wherever and whenever needed. Reusable test cases, immediately available to replay. No need to read manual pages to run a test case. No need to type or copy/paste code to replay a test Allow industrialization of test cases 9.2 Concerns of offensive programming Again neither exhaustive nor limitative, Non standard evaluation is always tricky and difficult to understand and put correctly in action, Runtime performance can be an issue, especially if you compare with standard R evaluation, as offensive programming adds two more kind of checks to be run to decide on result compliance Requires some experience with it to fill comfortable in design, build, and run. 9.3 Two extensions I identified two main extensions to wyz.code.offensiveProgramming package, especially useful when creating a R package. Unit test file code generation. Manual pages production 9.3.1 Unit test code generation From a recorded or transient test case set, it is possible to generate thesthat unit test file code, thus reducing work and time to create unit tests. Richness of result is tied to richness of the source set. 9.3.2 Manual pages production Automated production of R package manual pages is possible at a deeper level than traditional R approaches prompt. Reusing wisely recorded or transient test cases, could simplify a lot the generation of the example part of each manual page. Moreover, semantic naming, could also ease arguments part description. If pushed further, I could also consider class and function names to fill in automatically title part. I guess that with such approach, produced manual page should be filled in up to 80%, leaving about 20% of work to be done by developer. To be compared, to the 80% of work to be done when using prompt. 9.4 Your feedback is welcome Prior to implementation of extensions, I need your feedback about package wyz.code.offensiveProgramming. Your feedback about package usefulness, package usage, and package extensions is welcome, as any improvement suggestion.Share them, this will really help me. I you wish to contribute to package development, just drop me an email. "],
["references.html", "References", " References "]
]
