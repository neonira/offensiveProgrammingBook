[
["index.html", "Offensive Programming Book Welcome", " Offensive Programming Book Fabien GELINEAU neonira@gmail.com 2019-Q2 Welcome This is the website for “offensive programming”. This book will teach you how to put offensive programming in action with R. This website is and will remain free to use. It is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 3.0 License. The book is written in RMarkdown with bookdown. You may get access to the source for contributions. The book is for the moment just resulting of my efforts. Hope it will be enhanced and result from a collaborative effort very soon. This book is identified by ISBN 979-10-699-4075-8. "],
["preamble.html", "Preamble", " Preamble Package wyz.code.offensiveProgramming aims to provide a strict type checking enforcement in R. The R language is a weakly typed script language. As such, it simplifies greatly program writing and allows for great flexibility.That’s fine, and conceptually, there is no issue about that. Indeed, this leads more than desired to defensive programming practice. The absolute need to verify provided arguments, all along the function call chain, is very strong if you want to provide reliable and robust implementation. Consider following table about benefits of type control and type inference in lazy and strict type checking approaches. Goal Lazy type control (standard R) Strict type checking type control Weak type control implies coding of many contextual type controls Strong type checking brings some rigidity type inference requires knowledge and navigation from code to doc (forth and back) is required semantic naming allows more intuitive type inference Won’t it be nice to get the benefits of defensive programming and offensive programming, where ever and when ever needed? The main objective of package wyz.code.offensiveProgramming is to allow strict type checking in R to be as easy to use and to run as standard R "],
["programming-styles.html", " 1 Programming styles 1.1 Defensive programming style 1.2 Offensive programming style", " 1 Programming styles General reference might be found on wikiwand. 1.1 Defensive programming style Defensive programming style consist of implementation of many controls at the entry of functions. This is required to ensure parameters meet some conditions required by the developer or the context. There are some benefits to this style. It is clearly incremental, and you can always add as many controls as desired, to meet the level of robustness and reliability you aim for. Indeed, this comes with some drawbacks that are repeated verifications at various depth levels, and worst the executed verifications are often the same code, leading to a waste of time during implementation, testing and execution. Second, an evolution of any function signature in the function call chain, may imply shallow or deep changes in the subsequent verifications, depending of the case. Defensive programming style also requires a good documentation, as there is no way to infer rationally and with a high level of confidence, what type has to be used for a given parameter of a function. Notice, that quality and consistency of type and value verification changes from one package to another. 1.2 Offensive programming style Offensive programming styles works differently. It is based on an implicit contract with bilateral responsibilities developer implements required verification about values, not about types unless absolutely required, end-user provides values with right or wrong types, when using developer delivered package type checks can be enforced at any time by end-user if needed. They are not hard coded by the developer in each function. In this way, the contract, is end-user is responsible of type concordance and developer is responsible of implementation from type concordance. Instrumentation is provided to let the end-user easily check the type concordance. "],
["application-in-r-language.html", " 2 Application in R language 2.1 A simple case 2.2 Defensive programming 2.3 Offensive programming 2.4 Back to definition", " 2 Application in R language 2.1 A simple case Consider following R class implementation which provides some basic mathematics operations. MathOperation &lt;- function() { self &lt;- environment() class(self) &lt;- append(&#39;Addition&#39;, class(self)) add &lt;- function(x, y) x + y multiply &lt;- function(x, y) x * y divide &lt;- function(x, y) x / y self } Let’s not argue about the design and relevancy of the approach. Instead, can you tell the scopes of each function, and identify/inventorize the implementations flaws ? 2.2 Defensive programming In standard R, the provided implementation might behave correctly, erroneously, or even generate errors, depending on the inputs you provide. Is it bad code ? Not at all according to me. The class name mentions clearly the intent that is to encapsulate some math operations. There are 3 operations. They can take any argument that can be accepted by operators ‘+’, ’*’ or ‘/’. So, providing, integers, doubles, and complex numbers should work. If you use an external package like gmp, it is also an acceptable input for any of the needed parameters. Any combination of this types will provide a correct result, using scalars or vectors. From my point of view, main issues are the followings issue number issue description issue severity 1 few seconds for creation, several quarters of an hour for testing, and hours for documentation UNACCEPTABLE 2 does it complies with maths sets? Not at all, this is software engineering implementation, not a math compliant one SEVERE 3 high sensitivity to input values did you consider that NaN, NA, Inf, -Inf, 0 could be valid input values here?. Indeed R is naturally great on this part LOW 4 natural polymorphism of returned types, that brings again software engineering whereas reliable math ops are needed. From a mathematical point of view, input belong to a predefined mathematical set, and output belongs also to a predefined mathematical set. Not the case with provided implementations HIGH 5 unreliable implementation as input might return numeric output, warning or errors HIGH 2.3 Offensive programming Consider same R class implementation with a little bit instrumentation. suppressMessages(require(data.table)) MathOperation &lt;- function() { self &lt;- environment() class(self) &lt;- append(&#39;Addition&#39;, class(self)) add &lt;- function(x_r, y_r) x_r + y_r multiply &lt;- function(x_r, y_r) x_r * y_r divide &lt;- function(x_r, y_r) x_r / y_r function_return_types &lt;- data.table( function_name = c(&#39;add&#39;, &#39;multiply&#39;, &#39;divide&#39;), return_value = c(&#39;x_r&#39;, &#39;x_r&#39;, &#39;x_d&#39;) ) self } 2.3.1 What is different? Compare to previously shown implementation, here are the two main differences arguments are renamed according to a pattern a variable named function_return_types has been added. It holds a data.table that defines expected function return types. That’s it. Function implementation is exactly the same. No change done elsewhere. Everything is there and should be sufficient to solve many of the faced issues. 2.3.2 Semantic argument naming Arguments have been renamed from x to x_r. What does that mean? Syntactically, it changes nothing for R. For us humans, it changes a lot of things, as this follows a pattern that allows to specify several intents in a short, concise, and reliable way. The pattern is simple to understand. Its parts can be up to three, and the second and third parts are optional. First part, is the variable name. Second part is the type of the variable. Third part is the length constraint specification. Parts are separated by underscore. Refer to 5 for more details about syntax, and for illustrative examples. 2.4 Back to definition So now you may be able to translate the variable x_r by yourself. Just a vector of real values, unconstrained in length. Using this parameter name implies that the the developer is responsible for testing cases of various length and has to prevent weirdness propagation. For example following R code shows results that require decisions mo &lt;- MathOperation() print(mo$add(1.0 * 1:3, 1.0 * 1:7)) #&gt; Warning in x_r + y_r: la taille d&#39;un objet plus long n&#39;est pas multiple de #&gt; la taille d&#39;un objet plus court #&gt; [1] 2 4 6 5 7 9 8 This code provides both an output and a warning, because of R recycling on various length vectors. What decision should be taken ? Allow or deny this behavior ? It depends of your usage. If you are creating a real math library, I would recommend to duplicate the code and create two functions named addRCompliant and addMathCompliant. Later should enforce arguments length control in his body, while former should keep the body as is or instrument it with an encapsulating suppressWarning call. That way, you should easily meet your end-users expectations, either mathematicians or software engineers. Note that in the later case, added controls are not defensive programming but functional scope verification. "],
["putting-in-action-wyz-code-offensiveprogramming.html", " 3 Putting in action wyz.code.offensiveProgramming 3.1 Package overview", " 3 Putting in action wyz.code.offensiveProgramming The package provides R tools to ease offensive programming exploitation. 3.1 Package overview The package is organized around 4 axis that are elaboration, verification, exploitation and information. At any time you may get a list of the package functions by calling function packageFunctionsInformation that provides a truth table for each function in package wyz.code.offensiveProgramming. This is helpful when lost or just as a reminder. packageFunctionsInformation() #&gt; function elaboration verification #&gt; 1: defineEvaluationModes TRUE TRUE #&gt; 2: defineFunctionReturnTypesParameterName TRUE TRUE #&gt; 3: defineTestCaseDefinitionsParameterName TRUE TRUE #&gt; 4: EvaluationMode TRUE TRUE #&gt; 5: FunctionParameterTypeFactory TRUE TRUE #&gt; 6: FunctionParameterName TRUE TRUE #&gt; 7: TestCaseDefinition TRUE TRUE #&gt; 8: verifyClassName TRUE TRUE #&gt; 9: verifyFunctionName TRUE TRUE #&gt; 10: verifyObjectNames TRUE TRUE #&gt; 11: verifyFunctionReturnTypesDefinition TRUE TRUE #&gt; 12: verifyTestCaseDefinitions TRUE TRUE #&gt; 13: retrieveFunctionReturnTypes TRUE TRUE #&gt; 14: retrieveTestCaseDefinitions TRUE TRUE #&gt; 15: runFunction TRUE TRUE #&gt; 16: runTestCases TRUE TRUE #&gt; 17: packageFunctionsInformation TRUE TRUE #&gt; exploitation information kind user #&gt; 1: TRUE TRUE information developer #&gt; 2: TRUE TRUE information developer #&gt; 3: TRUE TRUE information developer #&gt; 4: TRUE TRUE elaboration developer #&gt; 5: TRUE TRUE elaboration developer #&gt; 6: FALSE FALSE elaboration developer #&gt; 7: FALSE FALSE elaboration developer #&gt; 8: TRUE TRUE verification developer #&gt; 9: TRUE TRUE verification developer #&gt; 10: TRUE TRUE verification developer #&gt; 11: TRUE TRUE verification integrator #&gt; 12: TRUE TRUE verification integrator #&gt; 13: TRUE TRUE exploitation integrator #&gt; 14: TRUE TRUE exploitation integrator #&gt; 15: TRUE TRUE exploitation end-user #&gt; 16: TRUE TRUE exploitation end-user #&gt; 17: TRUE TRUE information anyone "],
["the-type-factory.html", " 4 The type factory 4.1 Get recorded types inventory 4.2 Register your own type 4.3 Get access to verification functions 4.4 Some hints", " 4 The type factory The types that you wish to control are managed by a type factory, named FunctionParameterTypeFactory. Instantiating an object of this class allows you to discover what are the already available for reuse and recorded types register your own types so they can be checked dynamically wherever and whenever required understand the verification logic for each type 4.1 Get recorded types inventory Simply use retrieveFactory and getRecordedTypes functions. Here is an example. f &lt;- retrieveFactory() f$getRecordedTypes() #&gt; suffix type verify_function category #&gt; 1: a array &lt;function&gt; data structure #&gt; 2: b boolean &lt;function&gt; math #&gt; 3: c complex &lt;function&gt; numeric #&gt; 4: cm complex-math &lt;function&gt; math #&gt; 5: ca call &lt;function&gt; language #&gt; 6: d double &lt;function&gt; numeric #&gt; 7: da date &lt;function&gt; date #&gt; 8: dc POSIXct &lt;function&gt; date #&gt; 9: df data.frame &lt;function&gt; data structure #&gt; 10: dt data.table &lt;function&gt; data structure #&gt; 11: dl POSIXlt &lt;function&gt; date #&gt; 12: dm double-math &lt;function&gt; math #&gt; 13: e environment &lt;function&gt; basic #&gt; 14: ex expression &lt;function&gt; language #&gt; 15: er error &lt;function&gt; error management #&gt; 16: f function &lt;function&gt; basic #&gt; 17: fa factor &lt;function&gt; basic #&gt; 18: i integer &lt;function&gt; numeric #&gt; 19: im integer-math &lt;function&gt; math #&gt; 20: l list &lt;function&gt; data structure #&gt; 21: lo logical &lt;function&gt; basic #&gt; 22: m matrix &lt;function&gt; data structure #&gt; 23: n numeric &lt;function&gt; numeric #&gt; 24: na na &lt;function&gt; basic #&gt; 25: nm name &lt;function&gt; language #&gt; 26: o object &lt;function&gt; basic #&gt; 27: r real-math &lt;function&gt; math #&gt; 28: ra raw &lt;function&gt; basic #&gt; 29: s string &lt;function&gt; basic #&gt; 30: t table &lt;function&gt; data structure #&gt; 31: w warning &lt;function&gt; error management #&gt; suffix type verify_function category 4.2 Register your own type Type registration is achieved by providing a type suffix, a type name and a verification function. Registration will be tagged automatically as user-defined. Here is a typical sequence to register your own type f$addSuffix(&#39;mc&#39;, &#39;MyClass&#39;, function(o_1_) is(o_1_, &#39;MyClass&#39;)) #&gt; [1] TRUE f$getRecordedTypes()[suffix == &#39;mc&#39;] #&gt; suffix type verify_function category #&gt; 1: mc MyClass &lt;function&gt; user defined Note that no implementation of the class is required. It is purely declarative registration. You told the type factory to record the type MyClass under the suffix mc, with the verification function you provided. Here verification function is quite simple. Notice, that it takes a single object as argument. 4.3 Get access to verification functions Implementation of verification function can range from quite simple to as complex as required. This allows you to manage functional scopes much more easily, whatever you work and organization context. For example, if you want to see at a glance the differences between a boolean and a logical, here is the sequence you could use f$getVerificationFunction(&#39;b&#39;) #&gt; function(o_1_) is.logical(o_1_) &amp;&amp; !is.na(o_1_) #&gt; &lt;bytecode: 0x000000001d203638&gt; #&gt; &lt;environment: 0x000000001d37d398&gt; f$getVerificationFunction(&#39;logical&#39;) #&gt; function (x) .Primitive(&quot;is.logical&quot;) From the two definitions, you can deduce the differences between the two types. A boolean is a 2-value boolean, either TRUE or FALSE. A logical, is a R logical value, that is a 3-value boolean, so it may take value NA. Note that arguments to the function can be either a registered suffix or a registered type. 4.4 Some hints There is currently no way to remove one recorded type. This need is indeed very specific and arise only when there is a name collision and you wish to use an already taken name for your own purpose. Solution is quite simple, use another name. Provided types are the most commons, and the current suffixes have been chosen for ease of use and for intuitive usage. Whenever you need to register a new type, ask yourself ‘what is the suffix I wish to use for the new type?’. My advice is to use short suffixes, made of 2 or 3 letters. That’s clearly sufficient to distinguish your type from others. Know that there is not limitation to the length of the suffix you can use. Simply, comply with KISS, as you will have to type it several times. If you come from another programming language, you may consider to create aliased types by recording new entries. Let’s look at a concrete case. f$addSuffix(&#39;ui&#39;, &#39;unsigned integer&#39;, function(o_1_) f$getVerificationFunction(&#39;i&#39;)(o_1_) &amp;&amp; o_1_ &gt;= 0L) #&gt; [1] TRUE f$addSuffix(&#39;ul&#39;, &#39;unsigned long&#39; , f$getVerificationFunction(&#39;ui&#39;)) #&gt; [1] TRUE f$getRecordedTypes()[suffix %in% c(&#39;ui&#39;, &#39;ul&#39;)] #&gt; suffix type verify_function category #&gt; 1: ui unsigned integer &lt;function&gt; user defined #&gt; 2: ul unsigned long &lt;function&gt; user defined You just added two new entries in the type factory, and they share the same verification function. Now, ui and ul are aliases of the same verification function. Notice that this is true now, but can be changed whenever needed. In particular, you may change one or the other of the two functions as soon as you need to specialize the behavior. It depends largely on your case. The term alias shall not be understood, as an authorization to use one name for the other, but rather as an ability to define quickly new types to ease functional scope management. "],
["semantic-names.html", " 5 Semantic names 5.1 What is semantic naming? 5.2 Verifying a function parameter or return type declaration 5.3 Verifying a class name 5.4 Verifying a function name 5.5 Get naming balance from an R object", " 5 Semantic names Package wyz.code.offensiveProgramming offers great functionalities at the cost of a few conditions semantic naming has to be used for function parameters names semantic naming has to be used for function return type definition semantic naming has to be used for test case definitions 5.1 What is semantic naming? I call semantic naming, the fact that a named object used in the code should provide much more information than a dumb name. Semantic naming in package wyz.code.offensiveProgramming defines a few patterns to declare class, function, function parameters and function return type names. Table below shows the related patterns and exposes the underlying philosophy. name category philosophy pattern to comply with class java like, starts with upper-cased letter, camel-cased [A-Z][a-ZA-Z0-9]* function java like, starts with lower-cased letter, camel-cased [a-z][a-ZA-Z0-9]* function parameter or function return type R like, bearing information about type and length constraint See below. Function parameter or return type names must comply with one of the following patterns &lt;variableNameCamelCase&gt;_&lt;typeInformation&gt;_&lt;lengthConstraint&gt; &lt;variableNameCamelCase&gt;_&lt;lengthConstraint&gt;_ First pattern is to be used for monomorphic types. Second one for polymorphic types. Monomorphic types are types that are homogeneous. A string, a double, a MyObject are good example of such monomorphic types. Pattern allows to not only express concisely the type, but also to express some length constraints if needed. Polymorphic types are useful as soon as your input or output can take many types, according to your context. For example, a R function may return a double, or a warning, or an error. Polymorphic types always end with ’_’ in their names, to make them easy to identify. The type information part of the pattern has to match one of the recorded entries of the type factory. The length constraint part ot the pattern follows the PERL pattern ([1-9][0-9]*(l|m|n)?). Letters mean respectively less or equal, more or equal, 1 or n. The length constraint part is optional. Look at following table to get more intuitive traction on function parameter or function return type declarations. input name meaning x_s an unconstrained vector of strings - might contain no entries x_s_3 a vector of strings with 3 entries x_s_3l a vector of strings with 3 or less entries x_s_3m a vector of strings with 3 or more entries x_s_3n a vector of strings with 3 entries or 1 entry flag_b_1 a vector of booleans with 1 entry - a.k.a a boolean scalar z_ an unconstrained polymorphic type vector named z - Nothing more is known about its content z_2_ a polymorphic type vector named z of length 2 - Nothing more is known about its content As you can see, rather easy. An advice, when programming try to use meaningful variable names for first part of the pattern. It will ease your job. 5.2 Verifying a function parameter or return type declaration Use simply dedicated function named getTypeDescription from the type factory. sapply(c(&#39;x_s_3n&#39;, &#39;flag_b_1&#39;, &#39;z_2_&#39;), function(e) f$getTypeDescription(FunctionParameterName(e))) #&gt; x_s_3n #&gt; &quot;A constrained vector of string values. Vector length must be 1 or 3.&quot; #&gt; flag_b_1 #&gt; &quot;A constrained vector of boolean objects. Vector length must be 1.&quot; #&gt; z_2_ #&gt; &quot;A constrained vector of variable type objects. Vector length must be 2.&quot; 5.3 Verifying a class name Simply use package eponymous function. verifyClassName(c(&#39;alphaBeta&#39;, &#39;AlphaBeta&#39;, &#39;.alphaBeta&#39;)) #&gt; alphaBeta AlphaBeta .alphaBeta #&gt; FALSE TRUE FALSE verifyClassName(c(&#39;alphaBeta&#39;, &#39;AlphaBeta&#39;, &#39;.alphaBeta&#39;), strict = FALSE) #&gt; alphaBeta AlphaBeta .alphaBeta #&gt; TRUE TRUE TRUE 5.4 Verifying a function name Simply use package eponymous function. verifyFunctionName(c(&#39;alphaBetaGamma&#39;, &#39;AlphaBetaGamma&#39;, &#39;.alphaBetaGamma&#39;)) #&gt; alphaBetaGamma AlphaBetaGamma .alphaBetaGamma #&gt; TRUE FALSE FALSE verifyFunctionName(c(&#39;alphaBetaGamma&#39;, &#39;AlphaBetaGamma&#39;, &#39;.alphaBetaGamma&#39;), strict = FALSE) #&gt; alphaBetaGamma AlphaBetaGamma .alphaBetaGamma #&gt; TRUE TRUE TRUE 5.5 Get naming balance from an R object Use package function verifyObjectNames to get the results of a full compliance analysis of names for the provided object. source(system.file(&#39;code-samples/no-instrumentation/Addition.R&#39;, package = &#39;wyz.code.offensiveProgramming&#39;)) verifyObjectNames(Addition()) #&gt; $class_name_compliance #&gt; Addition #&gt; TRUE #&gt; #&gt; $function_name_compliance #&gt; addDouble addInteger addNumeric divideByZero #&gt; TRUE TRUE TRUE TRUE #&gt; generateError generateWarning #&gt; TRUE TRUE #&gt; #&gt; $parameter_name_compliance #&gt; function_name parameter_name name_compliance_check #&gt; 1: addDouble x_d TRUE #&gt; 2: addDouble y_d TRUE #&gt; 3: addInteger x_i TRUE #&gt; 4: addInteger y_i TRUE #&gt; 5: addNumeric x FALSE #&gt; 6: addNumeric y_n TRUE #&gt; 7: divideByZero x_n TRUE #&gt; 8: generateError &lt;NA&gt; TRUE #&gt; 9: generateWarning x_ TRUE #&gt; semantic_naming_check #&gt; 1: TRUE #&gt; 2: TRUE #&gt; 3: TRUE #&gt; 4: TRUE #&gt; 5: FALSE #&gt; 6: TRUE #&gt; 7: TRUE #&gt; 8: TRUE #&gt; 9: TRUE #&gt; #&gt; $classname #&gt; [1] &quot;Addition&quot; #&gt; #&gt; $owns_function_return_type_information #&gt; [1] FALSE #&gt; #&gt; $owns_test_case_definitions #&gt; [1] FALSE #&gt; #&gt; $supports_strict_compliance #&gt; [1] FALSE #&gt; #&gt; $supports_lazy_compliance #&gt; [1] FALSE #&gt; #&gt; $can_be_typed_checked #&gt; [1] FALSE #&gt; #&gt; $is_function_fully_instrumented #&gt; [1] FALSE #&gt; #&gt; $missing_functions #&gt; [1] NA #&gt; #&gt; $is_test_case_fully_instrumented #&gt; [1] FALSE #&gt; #&gt; $missing_test_cases #&gt; [1] NA source(system.file(&#39;code-samples/full-instrumentation/AdditionTCFIG1.R&#39;, package = &#39;wyz.code.offensiveProgramming&#39;)) verifyObjectNames(AdditionTCFIG1()) #&gt; $class_name_compliance #&gt; AdditionTCFIG1 #&gt; TRUE #&gt; #&gt; $function_name_compliance #&gt; addDouble addInteger addMultiDouble addMultiInteger #&gt; TRUE TRUE TRUE TRUE #&gt; addNumeric divideByZero generateError generateWarning #&gt; TRUE TRUE TRUE TRUE #&gt; #&gt; $parameter_name_compliance #&gt; function_name parameter_name name_compliance_check #&gt; 1: addDouble x_d TRUE #&gt; 2: addDouble y_d TRUE #&gt; 3: addInteger x_i TRUE #&gt; 4: addInteger y_i TRUE #&gt; 5: addMultiDouble ... TRUE #&gt; 6: addMultiInteger x_i TRUE #&gt; 7: addMultiInteger ... TRUE #&gt; 8: addNumeric x_n TRUE #&gt; 9: addNumeric y_n TRUE #&gt; 10: divideByZero x_n TRUE #&gt; 11: generateError &lt;NA&gt; TRUE #&gt; 12: generateWarning x_ TRUE #&gt; semantic_naming_check #&gt; 1: TRUE #&gt; 2: TRUE #&gt; 3: TRUE #&gt; 4: TRUE #&gt; 5: TRUE #&gt; 6: TRUE #&gt; 7: TRUE #&gt; 8: TRUE #&gt; 9: TRUE #&gt; 10: TRUE #&gt; 11: TRUE #&gt; 12: TRUE #&gt; #&gt; $classname #&gt; [1] &quot;AdditionTCFIG1&quot; #&gt; #&gt; $owns_function_return_type_information #&gt; [1] TRUE #&gt; #&gt; $owns_test_case_definitions #&gt; [1] TRUE #&gt; #&gt; $supports_strict_compliance #&gt; [1] TRUE #&gt; #&gt; $supports_lazy_compliance #&gt; [1] TRUE #&gt; #&gt; $can_be_typed_checked #&gt; [1] TRUE #&gt; #&gt; $is_function_fully_instrumented #&gt; [1] TRUE #&gt; #&gt; $missing_functions #&gt; [1] &quot;none&quot; #&gt; #&gt; $is_test_case_fully_instrumented #&gt; [1] FALSE #&gt; #&gt; $missing_test_cases #&gt; [1] &quot;addNumeric&quot; "],
["evaluation-modes.html", " 6 Evaluation modes 6.1 Understanding evaluation modes 6.2 Instantiating evaluation mode", " 6 Evaluation modes Package wyz.code.offensiveProgramming comes with several evaluation modes. You may retrieve them by using function defineEvaluationModes that returns the 3 following modes standard_R_evaluation enhanced_R_evaluation type_checking_enforcement 6.1 Understanding evaluation modes The first mode, standard_R_evaluation, is to ease comparisons with standard R evaluation. It does not make any sense to use only this mode when using wyz.code.offensiveProgramming. The second mode, enhanced_R_evaluation, goes further than standard R evaluation, as it implies a function return type verification. The third mode, type_checking_enforcement, goes still further than the second mode, as it implies a function parameter types verification. Roughly speaking, second mode let’s you verify function return types in accordance with recorded information, and the third mode, mimics a compiler output for R but it still interpreted language. 6.2 Instantiating evaluation mode To handle evaluation mode, use function EvaluationMode. A typical way to do so is em &lt;- EvaluationMode(defineEvaluationModes()[3]) "],
["running-functions.html", " 7 Running functions 7.1 Prerequisites 7.2 Function return types definition verification 7.3 Transient invocations 7.4 Persistent invocations", " 7 Running functions Our goal is to run a R instrumented function, under a given evaluation mode. To do so, some prerequisites have to be met, prior to use some wyz.code.offensiveProgramming utilities to proceed to the function execution with context capture and human-readable feedback generation. 7.1 Prerequisites To run a R function is has to be instrumented. Two requirements have to be met the function must comply with semantic parameter naming the function return type must be specified 7.2 Function return types definition verification To verify function return types definition you may use the low level function verifyFunctionReturnTypesDefinition or the higher level one named retrieveFunctionReturnTypes. Indeed, this approach requires persistent instrumentation of the code. retrieveFunctionReturnTypes(AdditionTCFIG1()) #&gt; function_name return_value #&gt; 1: addNumeric x_n #&gt; 2: addDouble x_d #&gt; 3: addInteger x_i #&gt; 4: addMultiDouble x_d #&gt; 5: divideByZero x_d #&gt; 6: addMultiInteger x_i #&gt; 7: generateWarning x_w #&gt; 8: generateError x_er 7.3 Transient invocations Transient means instrumentation is done dynamically and not persisted anywhere. Here is a typical case. That’s a convenient way to discover and to play with package wyz.code.offensiveProgramming. 7.3.1 Nominal case h &lt;- function(x_s) x_s runTransientFunction(h, list(&#39;neonira&#39;), EvaluationMode(defineEvaluationModes()[3]), &#39;x_s&#39;) #&gt; $status #&gt; [1] TRUE #&gt; #&gt; $value #&gt; [1] &quot;neonira&quot; #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_s neonira TRUE good type in values #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_s neonira TRUE good type in values Semantically, function h takes a vector of strings as argument and returns a vector of strings. As provided parameter ‘neonira’ is a vector of type character, parameter_type_checks succeed. As returned value is a vector of type character, function_return_type_check also succeeds. 7.3.1.1 Wrong parameter type Let’s change the provided argument from ‘neonira’ to pi value. h &lt;- function(x_s) x_s runTransientFunction(h, list(pi), EvaluationMode(defineEvaluationModes()[3]), &#39;x_s&#39;) #&gt; $status #&gt; [1] FALSE #&gt; #&gt; $value #&gt; [1] 3.141593 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_s 3.141593 FALSE wrong type in values #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_s 3.141593 FALSE wrong type in values We now face a case where function specification is unchanged but provided argument is not complying to specification. Impact is parameter_type_checks failure and function_return_type_check failure. 7.3.1.2 Change expected return type Let’s change the expected function return type, to be double x_d. h &lt;- function(x_s) x_s runTransientFunction(h, list(pi), EvaluationMode(defineEvaluationModes()[3]), &#39;x_d&#39;) #&gt; $status #&gt; [1] FALSE #&gt; #&gt; $value #&gt; [1] 3.141593 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_s 3.141593 FALSE wrong type in values #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_d 3.141593 TRUE good type in values We now face a case where function specification is unchanged but expected return type is expected to be a double. Provided argument is not complying to specification. Impact is parameter_type_checks failure. 7.3.2 Prerequisite mismatch What if function is not fulfilling prerequisites g &lt;- function(x) x # No semantic name compliance runTransientFunction(g, list(pi), EvaluationMode(defineEvaluationModes()[3]), &#39;x_d&#39;) #&gt; $status #&gt; [1] FALSE #&gt; #&gt; $value #&gt; [1] 3.141593 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x 3.141593 FALSE unknown suffix, [NA] #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_d 3.141593 TRUE good type in values Impact is parameter_type_checks failure. 7.4 Persistent invocations Transient invocations are convenient but limited. Especially, when you create classes, they do not appear to be as friendly and useful as necessary. When dealing with your own class code, you may opt for an easier and more industrial approach that is class instrumentation. Prerequisite remains the same, but you may fulfill them much more easily by defining a variable named function_return_type in your class. Let’s see an example. 7.4.1 Nominal persistent case source(system.file(&#39;code-samples/fun-defs/good/partial/AdditionFIPartial.R&#39;, package = &#39;wyz.code.offensiveProgramming&#39;)) runFunction(AdditionFIPartial(), &#39;addInteger&#39;, list(1:3, 6:8), EvaluationMode(defineEvaluationModes()[3])) #&gt; $status #&gt; [1] TRUE #&gt; #&gt; $value #&gt; [1] 7 9 11 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $function_return_check #&gt; [1] TRUE #&gt; #&gt; $parameter_check #&gt; [1] TRUE #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 1,2,3 TRUE good type in values #&gt; 2: y_i 6,7,8 TRUE good type in values #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 7, 9,11 TRUE good type in values We now face a case where function specification is expecting to sum integers. Provided arguments are complying to specification. Impact is parameter_type_checks success and function_return_type_check success. 7.4.2 Subtile change Just change the function name. Now expectations brought by the function definition are not the same. This leads to a completely different result. runFunction(AdditionFIPartial(), &#39;addDouble&#39;, list(1:3, 6:8), EvaluationMode(defineEvaluationModes()[3])) #&gt; $status #&gt; [1] FALSE #&gt; #&gt; $value #&gt; [1] 7 9 11 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $function_return_check #&gt; [1] FALSE #&gt; #&gt; $parameter_check #&gt; [1] FALSE #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_d 1,2,3 FALSE wrong type in values #&gt; 2: y_d 6,7,8 FALSE wrong type in values #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_d 7, 9,11 FALSE wrong type in values 7.4.3 Call case with named and positional parameters runFunction(AdditionFIPartial(), &#39;addInteger&#39;, list(y_i = 1:3, 6:8), EvaluationMode(defineEvaluationModes()[3])) #&gt; $status #&gt; [1] TRUE #&gt; #&gt; $value #&gt; [1] 7 9 11 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $function_return_check #&gt; [1] TRUE #&gt; #&gt; $parameter_check #&gt; [1] TRUE #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: y_i 1,2,3 TRUE good type in values #&gt; 2: x_i 6,7,8 TRUE good type in values #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 7, 9,11 TRUE good type in values Look at parameter_type_checks to ensure arguments are well associated. 7.4.4 Call case with ellipsis runFunction(AdditionFIPartial(), &#39;addMultiDouble&#39;, list(1:3, 1:7), EvaluationMode(defineEvaluationModes()[3])) #&gt; $status #&gt; [1] TRUE #&gt; #&gt; $value #&gt; [1] 34 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $function_return_check #&gt; [1] TRUE #&gt; #&gt; $parameter_check #&gt; [1] TRUE #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: ... 1,2,3 TRUE ellispsis match all #&gt; 2: ... 1,2,3,4,5,6,... TRUE ellispsis match all #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_d 34 TRUE good type in values 7.4.5 Second call case with ellipsis runFunction(AdditionFIPartial(), &#39;addMultiInteger&#39;, list(1:3, 1:7, 0, floor(pi)), EvaluationMode(defineEvaluationModes()[3])) #&gt; $status #&gt; [1] FALSE #&gt; #&gt; $value #&gt; [1] 32 33 34 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $function_return_check #&gt; [1] FALSE #&gt; #&gt; $parameter_check #&gt; [1] TRUE #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 1,2,3 TRUE good type in values #&gt; 2: ... 1,2,3,4,5,6,... TRUE ellispsis match all #&gt; 3: ... 0 TRUE ellispsis match all #&gt; 4: ... 3 TRUE ellispsis match all #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 32,33,34 FALSE wrong type in values Two issues here. Value 0 is double, not integer and floor function returns also a double. To get a correct results here is how to transform the call runFunction(AdditionFIPartial(), &#39;addMultiInteger&#39;, list(1:3, 1:7, 0L, as.integer(floor(pi))), EvaluationMode(defineEvaluationModes()[3])) #&gt; $status #&gt; [1] TRUE #&gt; #&gt; $value #&gt; [1] 32 33 34 #&gt; #&gt; $mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $function_return_check #&gt; [1] TRUE #&gt; #&gt; $parameter_check #&gt; [1] TRUE #&gt; #&gt; $parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 1,2,3 TRUE good type in values #&gt; 2: ... 1,2,3,4,5,6,... TRUE ellispsis match all #&gt; 3: ... 0 TRUE ellispsis match all #&gt; 4: ... 3 TRUE ellispsis match all #&gt; #&gt; $function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 32,33,34 TRUE good type in values "],
["running-test-cases.html", " 8 Running test cases 8.1 Embedding test cases in class definition 8.2 Test case definitions verification 8.3 Run a test case", " 8 Running test cases Using package wyz.code.offensiveProgramming, you have the opportunity to define test cases and to embed them in your class definition, to ease retrieval and reuse. 8.1 Embedding test cases in class definition This is accomplished easily. You just have to declare a variable named testCaseDefinitions, and provide its content, that is a data.table. Content could be partial or complete depending of your goals. Spectrum of provided tests cases is as you desire it to be, as shallow or deep as needed. The data.table must hold following columns and content function_name, a vector of strings, each being the name of the function to test, standard_evaluation, a vector of strings, where values are taken from set {‘correct’, ‘erroneous’, ‘failure’} type_checking_enforcement, , a vector of strings, where values are taken from set {‘correct’, ‘erroneous’, ‘failure’} test case definitions, that is a list of TestCaseDefinition objects. Correct implies right type and right result. Erroneous implies right type and wrong result. Failure implies wrong type. To get more details about syntax, please refer to manual page of Definitions. 8.1.1 A simple case source(system.file(&#39;code-samples/full-instrumentation/AdditionTCFIP.R&#39;, package = &#39;wyz.code.offensiveProgramming&#39;)) AdditionTCFIP #&gt; function () #&gt; { #&gt; self &lt;- environment() #&gt; class(self) &lt;- append(&quot;AdditionTCFIP&quot;, class(self)) #&gt; addNumeric &lt;- function(x_n, y_n) x_n + y_n #&gt; addDouble &lt;- function(x_d, y_d = 0, ...) x_d + y_d + ... #&gt; addInteger &lt;- function(x_i, y_i) x_i + y_i #&gt; divideByZero &lt;- function(x_n) x_n/0 #&gt; generateWarning &lt;- function(x_ = 8L) 1:3 + 1:7 + x_ #&gt; generateError &lt;- function() stop(&quot;generated error&quot;) #&gt; function_return_types &lt;- data.table(function_name = c(&quot;addNumeric&quot;, #&gt; &quot;addDouble&quot;, &quot;addInteger&quot;, &quot;divideByZero&quot;, &quot;generateWarning&quot;, #&gt; &quot;generateError&quot;), return_value = c(&quot;x_n&quot;, &quot;x_d&quot;, &quot;x_i&quot;, #&gt; &quot;x_d&quot;, &quot;x_w&quot;, &quot;x_er&quot;)) #&gt; test_case_definitions &lt;- data.table(function_name = c(&quot;addDouble&quot;, #&gt; &quot;addInteger&quot;, &quot;divideByZero&quot;, &quot;divideByZero&quot;, &quot;generateWarning&quot;, #&gt; &quot;generateError&quot;), standard_evaluation = c(&quot;correct&quot;, #&gt; &quot;correct&quot;, &quot;correct&quot;, &quot;correct&quot;, &quot;correct&quot;, &quot;failure&quot;), #&gt; type_checking_enforcement = c(&quot;correct&quot;, &quot;erroneous&quot;, #&gt; &quot;correct&quot;, &quot;correct&quot;, &quot;correct&quot;, &quot;correct&quot;), test_case = list(TestCaseDefinition(list(as.double(34L), #&gt; 44.5), 78.5, &quot;sum 2 doubles&quot;), TestCaseDefinition(list(34L, #&gt; 44.5), 78L, &quot;sum 1 integer and 1 double&quot;), TestCaseDefinition(list(1), #&gt; Inf, &quot;1 / 0&quot;), TestCaseDefinition(list(0), NaN, &quot;0 / 0&quot;), #&gt; TestCaseDefinition(list(0), 1:3 + 1:7, &quot;generate warning&quot;), #&gt; TestCaseDefinition(list(), NA, &quot;generate error&quot;))) #&gt; self #&gt; } Just five test cases to test 5 function with various parameters. 8.1.2 A more complex case AdditionTCFIG1 #&gt; function () #&gt; { #&gt; self &lt;- environment() #&gt; class(self) &lt;- append(&quot;AdditionTCFIG1&quot;, class(self)) #&gt; addNumeric &lt;- function(x_n, y_n) x_n + y_n #&gt; addDouble &lt;- function(x_d, y_d) x_d + y_d #&gt; addInteger &lt;- function(x_i, y_i) x_i + y_i #&gt; addMultiDouble &lt;- function(...) as.double(sum(..., na.rm = TRUE)) #&gt; addMultiInteger &lt;- function(x_i, ...) x_i + sum(..., na.rm = TRUE) #&gt; divideByZero &lt;- function(x_n) x_n/0 #&gt; generateWarning &lt;- function(x_) 1:3 + 1:7 #&gt; generateError &lt;- function() stop(&quot;generated error&quot;) #&gt; function_return_types &lt;- data.table(function_name = c(&quot;addNumeric&quot;, #&gt; &quot;addDouble&quot;, &quot;addInteger&quot;, &quot;addMultiDouble&quot;, &quot;divideByZero&quot;, #&gt; &quot;addMultiInteger&quot;, &quot;generateWarning&quot;, &quot;generateError&quot;), #&gt; return_value = c(&quot;x_n&quot;, &quot;x_d&quot;, &quot;x_i&quot;, &quot;x_d&quot;, &quot;x_d&quot;, &quot;x_i&quot;, #&gt; &quot;x_w&quot;, &quot;x_er&quot;)) #&gt; test_case_definitions &lt;- data.table(function_name = c(rep(&quot;addDouble&quot;, #&gt; 9), rep(&quot;addInteger&quot;, 9), rep(&quot;divideByZero&quot;, 3), &quot;generateWarning&quot;, #&gt; &quot;generateError&quot;, rep(&quot;addMultiDouble&quot;, 3), rep(&quot;addMultiInteger&quot;, #&gt; 3)), standard_evaluation = c(rep(&quot;correct&quot;, 5), &quot;erroneous&quot;, #&gt; rep(&quot;correct&quot;, 7), &quot;erroneous&quot;, rep(&quot;correct&quot;, 8), &quot;failure&quot;, #&gt; rep(&quot;correct&quot;, 6)), type_checking_enforcement = c(rep(&quot;correct&quot;, #&gt; 5), &quot;erroneous&quot;, rep(&quot;failure&quot;, 3), rep(&quot;correct&quot;, 4), #&gt; rep(&quot;failure&quot;, 5), rep(&quot;correct&quot;, 3), &quot;correct&quot;, &quot;failure&quot;, #&gt; &quot;correct&quot;, &quot;correct&quot;, &quot;correct&quot;, &quot;correct&quot;, &quot;failure&quot;, #&gt; &quot;correct&quot;), test_case = list(TestCaseDefinition(list(as.double(34L), #&gt; 44.5), 78.5, &quot;sum 2 doubles&quot;), TestCaseDefinition(list(34, #&gt; NA_real_), NA_real_, &quot;sum 1 double and 1 NA_real_&quot;), #&gt; TestCaseDefinition(list(NA_real_, NA_real_), NA_real_, #&gt; &quot;sum 2 NA_real_&quot;), TestCaseDefinition(list(NaN, NaN), #&gt; NaN, &quot;sum 2 NAN&quot;), TestCaseDefinition(list(Inf, Inf), #&gt; Inf, &quot;sum 2 Inf&quot;), TestCaseDefinition(list(as.integer(34.7), #&gt; as.integer(44.9)), 80, &quot;sum 2 as.integers confused with sum of rounded value as expectation&quot;), #&gt; TestCaseDefinition(list(34L, 44.5), 78.5, &quot;sum of 1 integer and 1 double&quot;), #&gt; TestCaseDefinition(list(34, NA_integer_), NA_real_, &quot;sum of 1 integer and 1 double&quot;), #&gt; TestCaseDefinition(list(NA, NA), NA, &quot;sum 2 NA&quot;), TestCaseDefinition(list(34L, #&gt; as.integer(44.5)), 78L, &quot;sum 2 integers&quot;), TestCaseDefinition(list(34L, #&gt; NA_integer_), NA_integer_, &quot;sum 1 integer and 1 NA_integer&quot;), #&gt; TestCaseDefinition(list(NA_integer_, NA_integer_), NA_integer_, #&gt; &quot;sum 2 NA_integer&quot;), TestCaseDefinition(list(as.integer(&quot;45.654&quot;), #&gt; 44L), 89L, &quot;sum a converted string with one integer&quot;), #&gt; TestCaseDefinition(list(34L, 44.5), 78L, &quot;sum 1 integer and 1 double&quot;), #&gt; TestCaseDefinition(list(34L, Inf), Inf, &quot;sum 1 integer and 1 Inf&quot;), #&gt; TestCaseDefinition(list(34L, NaN), NaN, &quot;sum 1 integer and 1 NAN&quot;), #&gt; TestCaseDefinition(list(34L, NA), NA, &quot;sum 1 integer and 1 NA&quot;), #&gt; TestCaseDefinition(list(c(34L, 35L), 44L), c(78L, 79L), #&gt; &quot;sum a vector of 2 integers with 1 integer&quot;), TestCaseDefinition(list(1), #&gt; Inf, &quot;1 / 0&quot;), TestCaseDefinition(list(-1), -Inf, #&gt; &quot;-1 / 0&quot;), TestCaseDefinition(list(0), NaN, &quot;0 / 0&quot;), #&gt; TestCaseDefinition(list(0), 1:3 + 1:7, &quot;generate warning&quot;), #&gt; TestCaseDefinition(list(), NA, &quot;generate error&quot;), TestCaseDefinition(list(34L, #&gt; 44.5), 78.5, &quot;sum of 1 integer and 1 double&quot;), TestCaseDefinition(list(34, #&gt; 35L, 36L, NA_integer_), 105, &quot;sum of 1 double, 2 integers and 1 NA_integer_&quot;), #&gt; TestCaseDefinition(list(), 0, &quot;sum of nothing&quot;), TestCaseDefinition(list(34L, #&gt; 44L, 1L, 1L), 80L, &quot;sum of 4 integers&quot;), TestCaseDefinition(list(34L, #&gt; 35, 36, NA_integer_), 105, &quot;sum of 1 integer, 2 doubles and 1 NA_integer_&quot;), #&gt; TestCaseDefinition(list(34L), 34L, &quot;sum of one integer and nothing&quot;))) #&gt; label &lt;- &quot;erroneous class instrumentation: test cases uses function divideByZero that is not instrumented for type checking enforcement&quot; #&gt; self #&gt; } #&gt; &lt;bytecode: 0x0000000017a14660&gt; Much more complete instrumentation with 29 test cases, various expected outputs, varying from evaluation model to consider. 8.2 Test case definitions verification To verify test cases definitions you may use the low level function verifyTestCaseDefinitions or the higher level one named retrieveTestCaseDefinitions. retrieveTestCaseDefinitions(AdditionTCFIG1()) #&gt; function_name standard_evaluation type_checking_enforcement #&gt; 1: addDouble correct correct #&gt; 2: addDouble correct correct #&gt; 3: addDouble correct correct #&gt; 4: addDouble correct correct #&gt; 5: addDouble correct correct #&gt; 6: addDouble erroneous erroneous #&gt; 7: addDouble correct failure #&gt; 8: addDouble correct failure #&gt; 9: addDouble correct failure #&gt; 10: addInteger correct correct #&gt; 11: addInteger correct correct #&gt; 12: addInteger correct correct #&gt; 13: addInteger correct correct #&gt; 14: addInteger erroneous failure #&gt; 15: addInteger correct failure #&gt; 16: addInteger correct failure #&gt; 17: addInteger correct failure #&gt; 18: addInteger correct failure #&gt; 19: divideByZero correct correct #&gt; 20: divideByZero correct correct #&gt; 21: divideByZero correct correct #&gt; 22: generateWarning correct correct #&gt; 23: generateError failure failure #&gt; 24: addMultiDouble correct correct #&gt; 25: addMultiDouble correct correct #&gt; 26: addMultiDouble correct correct #&gt; 27: addMultiInteger correct correct #&gt; 28: addMultiInteger correct failure #&gt; 29: addMultiInteger correct correct #&gt; function_name standard_evaluation type_checking_enforcement #&gt; test_case #&gt; 1: &lt;TestCaseDefinition&gt; #&gt; 2: &lt;TestCaseDefinition&gt; #&gt; 3: &lt;TestCaseDefinition&gt; #&gt; 4: &lt;TestCaseDefinition&gt; #&gt; 5: &lt;TestCaseDefinition&gt; #&gt; 6: &lt;TestCaseDefinition&gt; #&gt; 7: &lt;TestCaseDefinition&gt; #&gt; 8: &lt;TestCaseDefinition&gt; #&gt; 9: &lt;TestCaseDefinition&gt; #&gt; 10: &lt;TestCaseDefinition&gt; #&gt; 11: &lt;TestCaseDefinition&gt; #&gt; 12: &lt;TestCaseDefinition&gt; #&gt; 13: &lt;TestCaseDefinition&gt; #&gt; 14: &lt;TestCaseDefinition&gt; #&gt; 15: &lt;TestCaseDefinition&gt; #&gt; 16: &lt;TestCaseDefinition&gt; #&gt; 17: &lt;TestCaseDefinition&gt; #&gt; 18: &lt;TestCaseDefinition&gt; #&gt; 19: &lt;TestCaseDefinition&gt; #&gt; 20: &lt;TestCaseDefinition&gt; #&gt; 21: &lt;TestCaseDefinition&gt; #&gt; 22: &lt;TestCaseDefinition&gt; #&gt; 23: &lt;TestCaseDefinition&gt; #&gt; 24: &lt;TestCaseDefinition&gt; #&gt; 25: &lt;TestCaseDefinition&gt; #&gt; 26: &lt;TestCaseDefinition&gt; #&gt; 27: &lt;TestCaseDefinition&gt; #&gt; 28: &lt;TestCaseDefinition&gt; #&gt; 29: &lt;TestCaseDefinition&gt; #&gt; test_case 8.3 Run a test case To run a test case, you may use the package function runTestCase. runTestCase(AdditionTCFIG1(), 4, EvaluationMode(defineEvaluationModes()[3])) #&gt; $raw #&gt; $raw$addDouble #&gt; $raw$addDouble$status #&gt; [1] TRUE #&gt; #&gt; $raw$addDouble$value #&gt; [1] NaN #&gt; #&gt; $raw$addDouble$mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $raw$addDouble$function_return_check #&gt; [1] TRUE #&gt; #&gt; $raw$addDouble$parameter_check #&gt; [1] TRUE #&gt; #&gt; $raw$addDouble$parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_d NaN TRUE good type in values #&gt; 2: y_d NaN TRUE good type in values #&gt; #&gt; $raw$addDouble$function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_d NaN TRUE good type in values #&gt; #&gt; $raw$addDouble$index #&gt; [1] 4 #&gt; #&gt; $raw$addDouble$value_check #&gt; [1] TRUE #&gt; #&gt; $raw$addDouble$expected_evaluation #&gt; [1] &quot;correct&quot; #&gt; #&gt; $raw$addDouble$execution_evaluation #&gt; [1] &quot;correct&quot; #&gt; #&gt; $raw$addDouble$failure_origin #&gt; [1] NA #&gt; #&gt; #&gt; #&gt; $synthesis #&gt; status mode index value_check #&gt; 1: TRUE type_checking_enforcement 4 TRUE #&gt; function_return_check parameter_check expected_evaluation #&gt; 1: TRUE TRUE correct #&gt; execution_evaluation failure_origin #&gt; 1: correct &lt;NA&gt; This runs the test number 4. Result has two parts. A raw part, that holds the intermediate computation results, and a synthesis part that is a data.table provided to ease result interpretation. You can provide a vector instead of a single test number if you want to run several use test cases in one call. runTestCase(AdditionTCFIG1(), 12:17, EvaluationMode(defineEvaluationModes()[3])) #&gt; $raw #&gt; $raw$addInteger #&gt; $raw$addInteger$status #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$value #&gt; [1] NA #&gt; #&gt; $raw$addInteger$mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $raw$addInteger$function_return_check #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$parameter_check #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_i NA TRUE good type in values #&gt; 2: y_i NA TRUE good type in values #&gt; #&gt; $raw$addInteger$function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i NA TRUE good type in values #&gt; #&gt; $raw$addInteger$index #&gt; [1] 12 #&gt; #&gt; $raw$addInteger$value_check #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$expected_evaluation #&gt; [1] &quot;correct&quot; #&gt; #&gt; $raw$addInteger$execution_evaluation #&gt; [1] &quot;correct&quot; #&gt; #&gt; $raw$addInteger$failure_origin #&gt; [1] NA #&gt; #&gt; #&gt; $raw$addInteger #&gt; $raw$addInteger$status #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$value #&gt; [1] 89 #&gt; #&gt; $raw$addInteger$mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $raw$addInteger$function_return_check #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$parameter_check #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 45 TRUE good type in values #&gt; 2: y_i 44 TRUE good type in values #&gt; #&gt; $raw$addInteger$function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 89 TRUE good type in values #&gt; #&gt; $raw$addInteger$index #&gt; [1] 13 #&gt; #&gt; $raw$addInteger$value_check #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$expected_evaluation #&gt; [1] &quot;correct&quot; #&gt; #&gt; $raw$addInteger$execution_evaluation #&gt; [1] &quot;correct&quot; #&gt; #&gt; $raw$addInteger$failure_origin #&gt; [1] NA #&gt; #&gt; #&gt; $raw$addInteger #&gt; $raw$addInteger$status #&gt; [1] FALSE #&gt; #&gt; $raw$addInteger$value #&gt; [1] 78.5 #&gt; #&gt; $raw$addInteger$mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $raw$addInteger$function_return_check #&gt; [1] FALSE #&gt; #&gt; $raw$addInteger$parameter_check #&gt; [1] FALSE #&gt; #&gt; $raw$addInteger$parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 34 TRUE good type in values #&gt; 2: y_i 44.5 FALSE wrong type in values #&gt; #&gt; $raw$addInteger$function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 78.5 FALSE wrong type in values #&gt; #&gt; $raw$addInteger$index #&gt; [1] 14 #&gt; #&gt; $raw$addInteger$value_check #&gt; [1] FALSE #&gt; #&gt; $raw$addInteger$expected_evaluation #&gt; [1] &quot;failure&quot; #&gt; #&gt; $raw$addInteger$execution_evaluation #&gt; [1] &quot;failure&quot; #&gt; #&gt; $raw$addInteger$failure_origin #&gt; [1] &quot;function return type check, parameter check&quot; #&gt; #&gt; #&gt; $raw$addInteger #&gt; $raw$addInteger$status #&gt; [1] FALSE #&gt; #&gt; $raw$addInteger$value #&gt; [1] Inf #&gt; #&gt; $raw$addInteger$mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $raw$addInteger$function_return_check #&gt; [1] FALSE #&gt; #&gt; $raw$addInteger$parameter_check #&gt; [1] FALSE #&gt; #&gt; $raw$addInteger$parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 34 TRUE good type in values #&gt; 2: y_i Inf FALSE wrong type in values #&gt; #&gt; $raw$addInteger$function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i Inf FALSE wrong type in values #&gt; #&gt; $raw$addInteger$index #&gt; [1] 15 #&gt; #&gt; $raw$addInteger$value_check #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$expected_evaluation #&gt; [1] &quot;failure&quot; #&gt; #&gt; $raw$addInteger$execution_evaluation #&gt; [1] &quot;failure&quot; #&gt; #&gt; $raw$addInteger$failure_origin #&gt; [1] &quot;function return type check, parameter check&quot; #&gt; #&gt; #&gt; $raw$addInteger #&gt; $raw$addInteger$status #&gt; [1] FALSE #&gt; #&gt; $raw$addInteger$value #&gt; [1] NaN #&gt; #&gt; $raw$addInteger$mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $raw$addInteger$function_return_check #&gt; [1] FALSE #&gt; #&gt; $raw$addInteger$parameter_check #&gt; [1] FALSE #&gt; #&gt; $raw$addInteger$parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 34 TRUE good type in values #&gt; 2: y_i NaN FALSE wrong type in values #&gt; #&gt; $raw$addInteger$function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i NaN FALSE wrong type in values #&gt; #&gt; $raw$addInteger$index #&gt; [1] 16 #&gt; #&gt; $raw$addInteger$value_check #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$expected_evaluation #&gt; [1] &quot;failure&quot; #&gt; #&gt; $raw$addInteger$execution_evaluation #&gt; [1] &quot;failure&quot; #&gt; #&gt; $raw$addInteger$failure_origin #&gt; [1] &quot;function return type check, parameter check&quot; #&gt; #&gt; #&gt; $raw$addInteger #&gt; $raw$addInteger$status #&gt; [1] FALSE #&gt; #&gt; $raw$addInteger$value #&gt; [1] NA #&gt; #&gt; $raw$addInteger$mode #&gt; [1] &quot;type_checking_enforcement&quot; #&gt; #&gt; $raw$addInteger$function_return_check #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$parameter_check #&gt; [1] FALSE #&gt; #&gt; $raw$addInteger$parameter_type_checks #&gt; parameter_name parameter_value validity message #&gt; 1: x_i 34 TRUE good type in values #&gt; 2: y_i NA FALSE wrong type in values #&gt; #&gt; $raw$addInteger$function_return_type_check #&gt; parameter_name parameter_value validity message #&gt; 1: x_i NA TRUE good type in values #&gt; #&gt; $raw$addInteger$index #&gt; [1] 17 #&gt; #&gt; $raw$addInteger$value_check #&gt; [1] TRUE #&gt; #&gt; $raw$addInteger$expected_evaluation #&gt; [1] &quot;failure&quot; #&gt; #&gt; $raw$addInteger$execution_evaluation #&gt; [1] &quot;failure&quot; #&gt; #&gt; $raw$addInteger$failure_origin #&gt; [1] &quot;parameter check&quot; #&gt; #&gt; #&gt; #&gt; $synthesis #&gt; status mode index value_check #&gt; 1: TRUE type_checking_enforcement 12 TRUE #&gt; 2: TRUE type_checking_enforcement 13 TRUE #&gt; 3: FALSE type_checking_enforcement 14 FALSE #&gt; 4: FALSE type_checking_enforcement 15 TRUE #&gt; 5: FALSE type_checking_enforcement 16 TRUE #&gt; 6: FALSE type_checking_enforcement 17 TRUE #&gt; function_return_check parameter_check expected_evaluation #&gt; 1: TRUE TRUE correct #&gt; 2: TRUE TRUE correct #&gt; 3: FALSE FALSE failure #&gt; 4: FALSE FALSE failure #&gt; 5: FALSE FALSE failure #&gt; 6: TRUE FALSE failure #&gt; execution_evaluation failure_origin #&gt; 1: correct &lt;NA&gt; #&gt; 2: correct &lt;NA&gt; #&gt; 3: failure function return type check, parameter check #&gt; 4: failure function return type check, parameter check #&gt; 5: failure function return type check, parameter check #&gt; 6: failure parameter check Looking at synthesis, you will discover that test 17 fails under chosen evaluation mode, and therefore should require a fix. Here looking at raw results for test number 17, brings solution, that is about input parameter compliance. Provided values are double, whereas integers were expected. "],
["generating-testthat-test-files.html", " 9 Generating testthat test files 9.1 Package wyz.code.testthat in action 9.2 Generated unit test file content 9.3 Known-limits", " 9 Generating testthat test files When your R code is offensive programming instrumented, it becomes possible to generate testthat unit test files, thus improving greatly developers productivity. To be able to generate testthat unit test files, you must ensure that your R code is function return type instrumented and test cases instrumented. Both are required for this generation. 9.1 Package wyz.code.testthat in action 9.1.1 Setting up the context To create testthat unit test files, you must provide a target folder, to store the generated unit test files. In this session, generated files will be stored onto folder generated-testthat. You may change this, but be warned that generated files might be overwritten without any reminder. Be careful, if you set the target folder to tests/testthat as you may loose previous work. You may save frequently your results in configuration management to be able to retrieve original file content whenever required. Here, I reuse 4 files from package wyz.code.offensiveProgramming to generate unit test files from. library(wyz.code.testthat) target_folder &lt;- &#39;generated-testthat&#39; if (!dir.exists(target_folder)) dir.create(target_folder) generateTests &lt;- function(sourceFile_s_1, sourcePackage_s_1, object_o_1) { g &lt;- gautfo(object_o_1, sourceFile_s_1, sourcePackage_s_1, target_folder) print(g) g } source_package &lt;- &#39;wyz.code.offensiveProgramming&#39; source_files &lt;- c( &#39;code-samples/full-instrumentation/AdditionTCFIG1.R&#39;, &#39;code-samples/no-instrumentation/Addition.R&#39;, &#39;code-samples/fun-defs/good/partial/AdditionFIPartial.R&#39;, &#39;code-samples/tc-defs/good/partial/AdditionTCPartial.R&#39; ) invisible(sapply(source_files, function(e) { source(system.file(e, package = source_package)) })) 9.1.2 Unit test file generation Generation is done on a per class basis. Simply use function gautfo or function generateAllUnitTestsFromObject. 9.1.2.1 Nominal case Class AdditionTCFIG1 is offensive programming instrumented. It uses both function return type instrumentation and test case instrumentation. Indeed, this class is partially instrumented. Not all the methods of the class have test cases declared for. Generation is quite straightforward. print(gautfo(AdditionTCFIG1(), source_files[1], source_package, target_folder)) #&gt; $class #&gt; [1] &quot;AdditionTCFIG1&quot; #&gt; #&gt; $filenames #&gt; filename overwritten #&gt; 1: generated-testthat/test_AdditionTCFIG1-addDouble.R TRUE #&gt; 2: generated-testthat/test_AdditionTCFIG1-addInteger.R TRUE #&gt; 3: generated-testthat/test_AdditionTCFIG1-divideByZero.R TRUE #&gt; 4: generated-testthat/test_AdditionTCFIG1-generateWarning.R TRUE #&gt; 5: generated-testthat/test_AdditionTCFIG1-generateError.R TRUE #&gt; 6: generated-testthat/test_AdditionTCFIG1-addMultiDouble.R TRUE #&gt; 7: generated-testthat/test_AdditionTCFIG1-addMultiInteger.R TRUE Results is a list with two entries. Entry named filenames holds a data.table providing insight about created files. 9.1.2.2 Exception cases Class Addition is NOT offensive programming instrumented. Class AdditionFIPartial is NOT FULLY offensive programming instrumented. It lacks test cases instrumentation. Class AdditionTCPartial is NOT offensive programming instrumented. It lacks function return type instrumentation. Expected results is no unit test file generation. print(gautfo(Addition(), source_files[2], source_package, target_folder)) #&gt; [1] &quot;Class [Addition] apparently owns no test instrumentation. No test created.&quot; print(gautfo(AdditionFIPartial(), source_files[3], source_package, target_folder)) #&gt; [1] &quot;Class [AdditionFIPartial] apparently owns no test instrumentation. No test created.&quot; print(gautfo(AdditionTCPartial(), source_files[4], source_package, target_folder)) #&gt; [1] &quot;Class [AdditionTCPartial] apparently owns no function return type instrumentation. No test created.&quot; 9.2 Generated unit test file content Typically, generated R code will looks like following unit test code. Note, that comments are provided to ease cross-referencing and to link back easily to wyz.code.offensiveProgramming test case number. This is helpful when facing dysfunctions. source(system.file(&quot;code-samples/full-instrumentation/AdditionTCFIG1.R&quot;, package = &quot;wyz.code.offensiveProgramming&quot;)) object_o_1 &lt;- AdditionTCFIG1() emsre &lt;- EvaluationMode(&quot;standard_R_evaluation&quot;) rtcsre24 &lt;- runTestCase(object_o_1, 24, emsre) rtcsre25 &lt;- runTestCase(object_o_1, 25, emsre) rtcsre26 &lt;- runTestCase(object_o_1, 26, emsre) test_that(&#39;addMultiDouble&#39;, { # test 24 - sum of 1 integer and 1 double - correct expect_true(rtcsre24$synthesis$status) expect_true(rtcsre24$synthesis$value_check) # test 25 - sum of 1 double, 2 integers and 1 NA_integer_ - correct expect_true(rtcsre25$synthesis$status) expect_true(rtcsre25$synthesis$value_check) # test 26 - sum of nothing - correct expect_true(rtcsre26$synthesis$status) expect_true(rtcsre26$synthesis$value_check) }) emtce &lt;- EvaluationMode(&quot;type_checking_enforcement&quot;) rtctce24 &lt;- runTestCase(object_o_1, 24, emtce) rtctce25 &lt;- runTestCase(object_o_1, 25, emtce) rtctce26 &lt;- runTestCase(object_o_1, 26, emtce) test_that(&#39;addMultiDouble&#39;, { # test 24 - sum of 1 integer and 1 double - correct expect_true(rtctce24$synthesis$status) expect_true(rtctce24$synthesis$value_check) # test 25 - sum of 1 double, 2 integers and 1 NA_integer_ - correct expect_true(rtctce25$synthesis$status) expect_true(rtctce25$synthesis$value_check) # test 26 - sum of nothing - correct expect_true(rtctce26$synthesis$status) expect_true(rtctce26$synthesis$value_check) }) 9.3 Known-limits Generation of unit test file uses meta-programmation based on call function, and aims to produce R valid code. Indeed, format and presentation are not managed, in generated file. Used RStudio editing facilities to ensure nice presentation, although neither mandatory nor required. Generated tests cases are ready to run. Use the standard way to run your testthat test cases onto them. If you face some test failures, verify following points make sure offensive programming evaluation is running fine for ALL evaluation schemes, and that you have no errors at this level make sure your generated test case source is well up to date with the your R offensive programming code. You may regenerate your tests cases at any time if you have any doubt. Note that unit test file generated is fully dependent of your R source and of the instrumented scope. If there are function not instrumented in your source code, do not expect to have unit test cases for them. Also note, when working incrementally, you need to regenerate the unit test cases each time you change the R source code or the offensive programming instrumentation. Best way to put wyz.code.testthat in practice, is to apply following procedure apply offensive programming at the required scope and ensure wyz.code.offensiveProgramming test cases are valid, using runTestCase function generate testthat test cases in one single pass using wyz.code.testthat. To do so, create an R script. This will ease your pain, and will provide consistent results through calls apply testthat testing practice, to verify that generated tests are running fine. "],
["generating-r-documentation.html", " 10 Generating R documentation 10.1 Automated R documentation generation 10.2 Focus on R documentation generation 10.3 package wyz.code.rdoc utilities 10.4 Manual pages generation 10.5 Known-limits", " 10 Generating R documentation When your code uses offensive programming features, it becomes much easier to generate R documentation, as now, several information might be deduced and reused for manual pages composition. Let’s see how. 10.1 Automated R documentation generation Using package wyz.code.rdoc, manual pages .Rd files stored in man folder in a package context can be automatically created and filled up nearly to completion, depending on the level of offensive programming instrumentation of your code. Generated manual pages uses English language. Feel free to modify produced English, to match your own English flavor, if needed. The level of your R code instrumentation will impact the quality of the generation and your review work depth and time. When using both function return type instrumentation and test case instrumentation, expects produced manual page content to be fully generated and ready for review. No automated generation of manual page is possible when your code is not offensive programming instrumented. In such a case, rely either on standard R tools to generate documentation or use package wyz.code.rdoc to create the artifact program that will reduce the burden of documentation generation. 10.2 Focus on R documentation generation Package wyz.code.rdoc generates manual page sections, presented below with their information source and your remaining duties. R manual section information source your duty name R code none alias R code none, unless you want to add extraneous aliases title R code none usage R code none arguments R code none value R code none if your code is function return type instrumented. Otherwise, you will have to write explicitly this part. details R code you may complete this part that is generated when your code is function test case instrumented. references your instruction Generated from instructions you may provide. author package DESCRIPTION none seealso your instruction Generated from instructions you may provide. keyword your instruction Generated from instructions you may provide. examples R code none when your code is function test case instrumented. concept your instruction Generated from instructions you may provide. Missing sections can be added on your instruction when generating manual pages. Package wyz.code.rdoc provides a convenient and easy way to do so. The generated manual page can be used as-is, and should be immediately viewable and usable. From a format point of view, it complies with .Rd file syntax. From a content point of view, generated content aims to be reliable and express in human readable English wherever this makes sense. Indeed, you may bring desired enhancements to generated English sentences as you want. Generated manual page requires review. You may add extraneous content, modify provided content and beautify the result. See known limits section 9.3 to know more. 10.3 package wyz.code.rdoc utilities The package wyz.code.rdoc can be used to produce R documentation parts and R documentation generation programs. Here under are presented a few utilities that will greatly help you in producing high quality manual pages. Please, take time to read the full paragraph as it will mind you about some very convenient R functions to produces R code documentation snippets. For more information, refer to respective manual pages. 10.3.1 Generate a R documentation section Use function generateSection to generate a standard manual page section. Provide section name as first argument, and content as second. library(wyz.code.rdoc) print(generateSection(&#39;note&#39;, &#39;A note text.&#39;)) #&gt; [1] &quot;\\\\note{\\nA note text.\\n}&quot; This function does not allow you to generate a customized non standard manual page section. To do so, use generateContent. 10.3.2 Format an English sentence Use function sentensize to format a sentence. sentensize(&#39;some text \\t\\b will \\n\\b be generated&#39;) #&gt; [1] &quot;Some text will be generated.&quot; This functions ensures sentence starts with an upper-cased letter, adds a final dot if missing, and normalizes spaces, to ease readability. 10.3.3 Generate some R documentation content Use function generateContent to generate some R documentation content. Beware, as argument order is opposite to the one used for generateSection. print(generateContent(&#39;a title&#39;, &#39;title&#39;)) #&gt; [1] &quot;\\\\title{a title}&quot; print(generateContent(&#39;https://neonira.github.io/offensiveProgrammingBook/&#39;, &#39;href&#39;, &#39;Offensive Programming Book&#39;)) #&gt; [1] &quot;\\\\href{https://neonira.github.io/offensiveProgrammingBook/}{Offensive Programming Book}&quot; print(generateContent(&#39;warning&#39;, &#39;section&#39;, &#39;Warning section content ...&#39;)) #&gt; [1] &quot;\\\\section{warning}{\\nWarning section content ...\\n}&quot; print(generateContent(&#39;a&#39;, &#39;item&#39;, &#39;description of a&#39;, useSpace_b_1 = TRUE)) #&gt; [1] &quot;\\\\item{a} {description of a}&quot; print(generateContent(&#39;a&#39;, &#39;item&#39;, &#39;description of a&#39;, useSpace_b_1 = FALSE)) #&gt; [1] &quot;\\\\item{a}{description of a}&quot; 10.3.4 Generate cross-ref to other R package Use function generateSpecialLink to generate a R documentation cross-ref to any other R package. print(generateSpecialLink(&#39;wyz.code.offensiveProgramming&#39;, &#39;runTransientFunction&#39;)) #&gt; [1] &quot;\\\\link[wyz.code.offensiveProgramming:runTransientFunction]{wyz.code.offensiveProgramming:runTransientFunction}&quot; 10.4 Manual pages generation Simply use generateDocumentationContent to do so. 10.4.1 Context setup I will reuse some classes delivered with wyz.code.offensiveProgramming to ease demonstration of R documentation generation. target_folder &lt;- &#39;man&#39; #&quot;~/tmp/generated-doc&quot; if (!dir.exists(target_folder)) dir.create(target_folder) source_package &lt;- &#39;wyz.code.offensiveProgramming&#39; source_files &lt;- c( &#39;code-samples/full-instrumentation/AdditionTCFIG1.R&#39;, &#39;code-samples/no-instrumentation/Addition.R&#39;, &#39;code-samples/fun-defs/good/partial/AdditionFIPartial.R&#39;, &#39;code-samples/tc-defs/good/partial/AdditionTCPartial.R&#39; ) invisible(sapply(source_files, function(e) { source(system.file(e, package = source_package)) })) 10.4.2 Method manual page Use keyword method to generate a dedicated manual page for an S3 method. object &lt;- AdditionTCFIG1() package_name &lt;- &#39;zorg&#39; refs &lt;- list( list(url = &#39;https://cran.r-project.org/doc/manuals/R-exts.html&#39;, label = &#39;Writing R extensions&#39;, comment = &#39;to know more about R documentation requirements&#39;), list(url = &#39;https://www.burns-stat.com/pages/Tutor/R_inferno.pdf&#39;, label = &#39;The R Inferno&#39;, comment = &#39;to discover some well-known R weirdness&#39;) ) extra_method &lt;- list( keyword = c(&#39;classes&#39;, &#39;environment&#39;, &#39;utilities&#39;, &#39;misc&#39;), concept = c(&#39;evaluation mode&#39;, &#39;standard evaluation&#39;, &#39;function return type evaluation&#39;, &#39;parameter check evaluation&#39;), references = c(sentensize(paste(&#39;see&#39;, generateContent(&#39;wyz.code.offensiveProgramming&#39;, &#39;code&#39;), &#39;package documentation&#39;)), &#39;&#39;, sentensize(paste(&#39;You may read&#39;, generateContent(&#39;https://neonira.github.io/offensiveProgrammingBook/&#39;, &#39;href&#39;, &#39;Offensive Programming Book&#39;), &#39;to get introduction and expert advices on offensive programming&#39;)), &#39;&#39;, generateReference(refs[[1]]) ), seealso = c(sentensize(paste(&#39;see&#39;, generateContent(generateSpecialLink(&#39;wyz.code.offensiveProgramming&#39;, &#39;runTransientFunction&#39;), &#39;code&#39;), &#39;to call interactively an offensive programming function, whether instrumented or not.&#39;)), &#39;&#39;, sentensize(paste(&#39;see&#39;, generateContent(generateSpecialLink(&#39;wyz.code.offensiveProgramming&#39;, &#39;runTestCase&#39;), &#39;code&#39;), &#39;to reuse on-demand instrumented offensive programming function tests&#39;)) ) ) # explicit invocation for method generateDocumentationContent(target_folder, &#39;method&#39;, &#39;addMultiDouble&#39;, object, package_name, extra_method, overwrite_b_1 = TRUE) #&gt; wrote file man/addMultiDouble.AdditionTCFIG1.Rd Note how parameter extra_method allows you to provide specific content as instruction to be considered for manual page generation. The extraneous content must be a list, where names are manual page sections, and where content is R documentation content. You may use function generateDocumentationContent to generate your own R documentation generation scripts. This allows you to generate programmatically your manual pages. Note that parameter package_name is the name of the target package you want to generate documentation for. Here, files are taken from the wyz.code.offensiveProgramming package, and documentation is generated for package zorg. Really useful when programming, not so useful when used interactively. 10.4.3 Class manual page Use keyword class to create a manual page for a class. Provide the class name. extra_class &lt;- extra_method extra_class$references &lt;- extra_method$references[[5]] extra_class$seealso &lt;- NULL generateDocumentationContent(target_folder, &#39;class&#39;, &#39;AdditionTCFIG1&#39;, object, package_name, extra_class, overwrite_b_1 = TRUE) #&gt; wrote file man/AdditionTCFIG1.Rd 10.4.4 Package manual page Use keyword class to generate a summary manual page for your package. Provide explicitly, all the class names you desired to emphase over. extra_package &lt;- extra_method extra_package$seealso &lt;- NULL extra_package$content &lt;- c(&#39;AdditionTCFIG1&#39;, &#39;AdditionTCFIP&#39;, &#39;Addition&#39;) z &lt;- generateDocumentationContent(target_folder, &#39;package&#39;, package_name, object, package_name, extra_package, overwrite_b_1 = TRUE) #&gt; wrote file man/zorg-package.Rd Result is \\name{zorg-package} \\alias{zorg-package} \\alias{zorg} \\docType{package} \\title{\\packageTitle{zorg}} \\description{ \\packageDescription{zorg} } \\details{ Most important package entries are \\itemize{ \\item{\\code{\\link{AdditionTCFIG1}}}{} \\item{\\code{\\link{AdditionTCFIP}}}{} \\item{\\code{\\link{Addition}}}{} } } \\references{ See \\code{wyz.code.offensiveProgramming} package documentation. You may read \\href{https://neonira.github.io/offensiveProgrammingBook/}{Offensive Programming Book} to get introduction and expert advices on offensive programming. Refer to \\href{https://cran.r-project.org/doc/manuals/R-exts.html}{Writing R extensions} to know more about R documentation requirements. } \\author{ \\packageAuthor{zorg} Maintainer: \\packageMaintainer{zorg} } \\keyword{classes} \\keyword{environment} \\keyword{utilities} \\keyword{misc} \\concept{evaluation mode} \\concept{standard evaluation} \\concept{function return type evaluation} \\concept{parameter check evaluation} 10.4.5 In one shot To simplify your life, you can create in one shot all the manual pages related to methods of a class. Simply pass NA as value for the name. generateDocumentationContent(target_folder, &#39;method&#39;, NA, AdditionTCPartial(), package_name, extra_method, overwrite_b_1 = TRUE) #&gt; wrote file man/addDouble.AdditionTCPartial.Rd #&gt; wrote file man/addInteger.AdditionTCPartial.Rd #&gt; wrote file man/addNumeric.AdditionTCPartial.Rd #&gt; wrote file man/divideByZero.AdditionTCPartial.Rd #&gt; wrote file man/generateError.AdditionTCPartial.Rd #&gt; wrote file man/generateWarning.AdditionTCPartial.Rd #&gt; $addDouble #&gt; $addDouble$filename #&gt; [1] &quot;man/addDouble.AdditionTCPartial.Rd&quot; #&gt; #&gt; $addDouble$overwritten #&gt; [1] TRUE #&gt; #&gt; #&gt; $addInteger #&gt; $addInteger$filename #&gt; [1] &quot;man/addInteger.AdditionTCPartial.Rd&quot; #&gt; #&gt; $addInteger$overwritten #&gt; [1] TRUE #&gt; #&gt; #&gt; $addNumeric #&gt; $addNumeric$filename #&gt; [1] &quot;man/addNumeric.AdditionTCPartial.Rd&quot; #&gt; #&gt; $addNumeric$overwritten #&gt; [1] TRUE #&gt; #&gt; #&gt; $divideByZero #&gt; $divideByZero$filename #&gt; [1] &quot;man/divideByZero.AdditionTCPartial.Rd&quot; #&gt; #&gt; $divideByZero$overwritten #&gt; [1] TRUE #&gt; #&gt; #&gt; $generateError #&gt; $generateError$filename #&gt; [1] &quot;man/generateError.AdditionTCPartial.Rd&quot; #&gt; #&gt; $generateError$overwritten #&gt; [1] TRUE #&gt; #&gt; #&gt; $generateWarning #&gt; $generateWarning$filename #&gt; [1] &quot;man/generateWarning.AdditionTCPartial.Rd&quot; #&gt; #&gt; $generateWarning$overwritten #&gt; [1] TRUE 10.5 Known-limits Generation of manual pages can be quite tricky. Whereas package wyz.code.rdoc alleviates greatly the burden, some pitfalls remain. Here they are Generated manual page might not respect the maximum line length required by R CMD check. This tool will provide explicit information about un-compliance. To solve issue, just split the content by adding carriage return wherever required. Generated documentation is quite stereotyped. Inject your instruction to customize the result. Apply KISS. "],
["conclusion.html", " 11 Conclusion 11.1 Benefits of offensive programming 11.2 Concerns of offensive programming 11.3 Your feedback is welcome", " 11 Conclusion 11.1 Benefits of offensive programming Neither exhaustive nor limitative list. Main benefits are Applicable to new and legacy code Code instrumentation at the required level, according to your needs. No obligation to comply completely or to instrument completely. Transient or persistent approach allow to deal with code you own and code you do not own. Evaluation modes eases incremental work. Offensive programming type_checking_enforcement mode is complimentary of standard R evaluation mode, not contesting with it. Usable at build time, at test time, and at run time wherever and whenever needed. Reusable test cases, immediately available to replay. No need to read manual pages to run a test case. No need to type or copy/paste code to replay a test Allow industrialization of test cases Allow fully automated generation of testthat test cases Allow fully automated generation of R documentation Most of all, offensive programming brings following value reduced code size, as many checks are no more necessary and shall no more be implemented higher developer’s productivity on R implementation, although earned time is varying greatly from function to function, depending of its complexity. I got more than 15% of time gain using offensive programming coding on several R package creations. Automated test case generation reduces greatly the burden of testthat content generation. Expect a productivity gain higher than 70% here. Documentation creation is now reduced in a great proportion, leaving just the review at your charge. Expect a productivity gain higher than 80% here. increased execution speed, due to reduced and simplified code. Again, many checks are no more necessary, and comparing, some traditional R code with offensive programming R code, will bring a clear value in favor of the second, as it tends not only to reduce the volume of code, but also to simplify your R code and to ease bug avoidance. The root cause of these two improvements is coming from type purity. 11.2 Concerns of offensive programming Again a neither exhaustive nor limitative list Non standard evaluation is always tricky and difficult to understand and put correctly in action, due to the two evaluation paradigms that are different from traditional R logic. Offensive programming is to be used wherever R standard evaluation scheme appears too limited or too lazy. The two extraneous evaluation paradigms might bring runtime performance issues, especially if you compare with standard R evaluation. Indeed, doing so is unfair, as it is not comparing apple to apple. Offensive programming adds two more kind of checks to be run to decide on result compliance, that are simply unknown from R standard evaluation scheme. Offensive programming requires some experience with it to fill comfortable in design, build, and run. Nevertheless, quite simple and intuitive, from a programming point of view. One piece of advice, be sure to have a clear idea of what you expect. In standard R, we are all used to get results without even asking ourselves any question about types, polymorphism, parameters and computed results. With offensive programming you must be able to answer clearly to such questions. 11.3 Your feedback is welcome Your feedback about package usefulness, package usage, and package extensions is welcome, as any improvement suggestion.Share them, this will really help me. I you wish to contribute to package development, just drop me an email. "],
["references.html", "References", " References "]
]
